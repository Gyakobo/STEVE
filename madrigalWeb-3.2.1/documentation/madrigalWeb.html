<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>madrigalWeb.madrigalWeb API documentation</title>
<meta name="description" content="The madrigalWeb module provides access to all Madrigal data via web services." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>madrigalWeb.madrigalWeb</code></h1>
</header>
<section id="section-intro">
<p>The madrigalWeb module provides access to all Madrigal data via web services.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;The madrigalWeb module provides access to all Madrigal data via web services.

&#34;&#34;&#34;

# $Id: madrigalWeb.py 7369 2021-04-22 17:55:08Z brideout $


import os, os.path, sys
import traceback
try:                        # Python 3
    import urllib.request as urllib2
    import urllib.parse as urlparse
except ImportError:         # Python 2
    import urllib, urllib2, urlparse
import types
import re
import datetime
import distutils.version

# constants
TIMEOUT = 60 * 30 # timeout in seconds before skipping file
TIMEOUT2 = 60 * 3 # shorter time out

def isStringType(input):
    &#34;&#34;&#34;isStringType is a method designed to work with both python 2 and 3 to test for string type
    &#34;&#34;&#34;
    if type(input) == str:
        return(True)
    try:
        if type(input) == unicode:
            return(True)
    except:
        return(False)
    return(False)


class MadrigalData:
    &#34;&#34;&#34;MadrigalData is a class that acquires data from a particular Madrigal site.


    Usage example::

        import madrigalWeb.madrigalWeb
    
        test =  madrigalWeb.madrigalWeb.MadrigalData(&#39;http://madrigal.haystack.mit.edu&#39;)

        instList = test.getInstrumentList()
            


    Non-standard Python modules used: None


    Change history:

    Written by &#34;Bill Rideout&#34;:mailto:wrideout@haystack.mit.edu  Feb. 10, 2004

    &#34;&#34;&#34;
    def __init__(self, url):
        &#34;&#34;&#34;__init__ initializes a MadrigalData object.

        Inputs::

            url - (string) url of main page of madrigal site. Example: &#39;http://madrigal.haystack.mit.edu&#39;

        Affects: Converts main page to cgi url, and stores that.

        Also stores self.siteDict, with key = site id, value= site url, and self.siteId

        Exceptions: If url not found.
        &#34;&#34;&#34;
        cgiName = &#39;accessData.cgi&#39;

        regExp = re.compile(&#39;&#34;.*&#39; + cgiName)

        # get base of url
        urlParts = urlparse.urlparse(url)

        urlBase = urlParts[0] + &#39;://&#39; + urlParts[1]

        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
        except:
            raise ValueError(&#39;unable to open url &#39; + str(url))

        page = mainUrl.read().decode(&#39;utf-8&#39;)
        
        mainUrl.close()

        result = regExp.search(page)
        
        # check for success
        if result == None:
            raise ValueError(&#39;invalid url: &#39; + str(url))

        result = result.group()
        
        if type(result) in (list, tuple):
            result = result[0]
            
        self.cgiurl = urlBase + result[1:(-1*len(cgiName))]

        try:
            self.siteDict = self.__getSiteDict()
        except:
            self.cgiurl = url
            if not self.cgiurl[-1] == &#39;/&#39;:
                self.cgiurl += &#39;/&#39;
            self.siteDict = self.__getSiteDict()
            

        self.siteId = self.__getSiteId()
        
        # get Madrigal version
        self._madVers = self.getVersion()


    def __getSiteDict(self):
        &#34;&#34;&#34;__getSiteDict returns a dictionary with key = site id, value= site url.

        Uses getMetadata cgi script
        &#34;&#34;&#34;
        url = urlparse.urljoin(self.cgiurl, &#39;getMetadata?fileType=5&#39;)
        
        f = urllib2.urlopen(url, timeout=TIMEOUT2)

        page = f.read().decode(&#39;utf-8&#39;)

        f.close()

        lines = page.split(&#39;\n&#39;)

        siteDict = {}

        for line in lines:
            items = line.split(&#39;,&#39;)
            if len(items) &lt; 4:
                continue
            site = int(items[0])
            thisUrl = &#39;http://%s/%s&#39; % (items[2], items[3])
            siteDict[site] = thisUrl

        return siteDict


    def __getSiteId(self):
        &#34;&#34;&#34;__getSiteId returns the local site id

        Uses getMetadata cgi script
        &#34;&#34;&#34;
        url = urlparse.urljoin(self.cgiurl, &#39;getMetadata?fileType=0&#39;)

        f = urllib2.urlopen(url, timeout=TIMEOUT2)

        page = f.read().decode(&#39;utf-8&#39;)

        f.close()

        lines = page.split(&#39;\n&#39;)

        for line in lines:
            items = line.split(&#39;,&#39;)
            if len(items) &lt; 4:
                continue
            siteId = int(items[3])
            return(siteId)

        raise IOError(&#39;No siteId found&#39;)
            
        



    def getAllInstruments(self):
        &#34;&#34;&#34; returns a list of all MadrigalInstruments at the given Madrigal site&#34;&#34;&#34;

        scriptName = &#39;getInstrumentsService.py&#39;

        url = self.cgiurl + scriptName

        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
        except:
            raise ValueError(&#39;unable to open url &#39; + str(url))

        page = mainUrl.read().decode(&#39;utf8&#39;)
        page = page.split(&#39;\n&#39;)

        mainUrl.close()

        # parse the result
        if len(page) == 0:
            raise ValueError(&#39;No data found at url&#39; + str(url))

        # check that html was not returned
        for line in page:
            if line.find(&#39;Error occurred&#39;) != -1:
                raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

        result = []

        for line in page:
            items = line.split(&#39;,&#39;)
            if len(items) &lt; 5:
                continue
            if len(items) &gt; 6:
                category = items[6]
            else:
                category = &#39;unknown&#39;
            result.append(MadrigalInstrument(items[0],
                                             items[1],
                                             items[2],
                                             items[3],
                                             items[4],
                                             items[5],
                                             category))

        return result


    
    def getExperiments(self,
                       code,
                       startyear,
                       startmonth,
                       startday,
                       starthour,
                       startmin,
                       startsec,
                       endyear,
                       endmonth,
                       endday,
                       endhour,
                       endmin,
                       endsec,
                       local=1):
        &#34;&#34;&#34; returns a list of all MadrigalExperiments that meet criteria at the given Madrigal site

        Inputs:

           code - int or list of ints representing instrument code(s). Special value of 0 selects all instruments.
           
           startyear - int or string convertable to int
           
           startmonth - int or string convertable to int
           
           startday - int or string convertable to int
           
           starthour - int or string convertable to int
           
           startmin - int or string convertable to int
           
           startsec - int or string convertable to int
           
           endyear - int or string convertable to int
           
           endmonth - int or string convertable to int
           
           endday - int or string convertable to int
           
           endhour - int or string convertable to int
           
           endmin - int or string convertable to int
           
           endsec - int or string convertable to int

           local - 0 if all sites desired, 1 (default) if only local experiments desired

        Outputs:

            List of MadrigalExperiment objects that meet the criteria.  Note that if the returned
            MadrigalExperiment is not local, the experiment id will be -1.  This means that you
            will need to create a new MadrigalData object with the url of the 
            non-local experiment (MadrigalExperiment.madrigalUrl), and then call 
            getExperiments a second time using that Madrigal url.  This is because 
            while Madrigal sites share metadata about experiments, the real experiment ids are only
            known by the individual Madrigal sites.  See examples/exampleMadrigalWebServices.py
            for an example of this.


        &#34;&#34;&#34;

        scriptName = &#39;getExperimentsService.py&#39;

        url = self.cgiurl + scriptName + &#39;?&#39;

        # first append code(s)
        if type(code) == list:
            for item in code:
                url += &#39;code=%i&amp;&#39; % (int(item))
        else:
            url += &#39;code=%i&amp;&#39; % (int(code))

        # append times
        url += &#39;startyear=%i&amp;&#39; % (int(startyear))
        url += &#39;startmonth=%i&amp;&#39; % (int(startmonth))
        url += &#39;startday=%i&amp;&#39; % (int(startday))
        url += &#39;starthour=%i&amp;&#39; % (int(starthour))
        url += &#39;startmin=%i&amp;&#39; % (int(startmin))
        url += &#39;startsec=%i&amp;&#39; % (int(startsec))
        url += &#39;endyear=%i&amp;&#39; % (int(endyear))
        url += &#39;endmonth=%i&amp;&#39; % (int(endmonth))
        url += &#39;endday=%i&amp;&#39; % (int(endday))
        url += &#39;endhour=%i&amp;&#39; % (int(endhour))
        url += &#39;endmin=%i&amp;&#39; % (int(endmin))
        url += &#39;endsec=%i&amp;&#39; % (int(endsec))
        url += &#39;local=%i&#39;% (int(local))
        


        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
        except:
            raise ValueError(&#39;unable to open url &#39; + str(url))
                

        

        page = mainUrl.read().decode(&#39;utf8&#39;, errors=&#39;replace&#39;)
        page = page.split(&#39;\n&#39;)

        mainUrl.close()

        # parse the result
        if len(page) == 0:
            return []

        # check that error was not returned
        for line in page:
            if line.find(&#39;Error occurred&#39;) != -1:
                raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

        result = []


        for line in page:
            items = line.split(&#39;,&#39;)
            # calculate isLocal
            if len(items) &lt; 20:
                continue
            if int(items[3]) == self.siteId:
                isLocal = True
            else:
                isLocal = False
            if isLocal:
                expIdStr = items[0]
            else:
                expIdStr = &#39;-1&#39;
            if len(items) &gt; 21:
                pi = items[20]
                piEmail = items[21]
            else:
                pi = &#39;unknown&#39;
                piEmail = &#39;unknown&#39;
            if len(items) &gt; 23:
                uttimestamp = int(items[22])
                access = int(items[23])
            else:
                uttimestamp = None
                access = None
                
            result.append(MadrigalExperiment(expIdStr,
                                             items[1],
                                             items[2],
                                             items[3],
                                             items[4],
                                             items[5],
                                             items[6],
                                             items[7],
                                             items[8],
                                             items[9],
                                             items[10],
                                             items[11],
                                             items[12],
                                             items[13],
                                             items[14],
                                             items[15],
                                             items[16],
                                             items[17],
                                             items[18],
                                             isLocal,
                                             self.siteDict[int(items[3])],
                                             pi,
                                             piEmail,
                                             uttimestamp,
                                             access,
                                             self._madVers))
            

        return result


    def getExperimentFiles(self, id, getNonDefault=False):
        &#34;&#34;&#34; returns a list of all default MadrigalExperimentFiles for a given experiment id

        Inputs:

           id - Experiment id.

           getNonDefault - if False (the default), only get default files, or realtime
                           files if no default files found.  If True, get all files.
                           In general, users should set this to False because default files
                           are the most reliable.

        Outputs:

            List of MadrigalExperimentFile objects for that experiment id


        &#34;&#34;&#34;

        scriptName = &#39;getExperimentFilesService.py&#39;
        
        if int(id) == -1:
            err_str = &#34;&#34;&#34;Illegal experiment id -1.  This is usually caused by calling
            getExperiments with the isLocal flag set to 0.  To get the experiment id for a non-local
            experiment, you will need to create a new MadrigalData object with the url of the 
            non-local experiment (MadrigalExperiment.madrigalUrl), and then call 
            getExperiments a second time using that Madrigal url.  This is because 
            while Madrigal sites share metadata about experiments, the real experiment ids are only
            known by the individual Madrigal sites. See examples/exampleMadrigalWebServices.py
            for an example of this.
            &#34;&#34;&#34;
            raise ValueError(err_str)

        url = self.cgiurl + scriptName + &#39;?id=%i&#39; % (int(id))


        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
        except:
            raise ValueError(&#39;unable to open url &#39; + str(url))
                

        page = mainUrl.read().decode(&#39;utf8&#39;)
        page = page.split(&#39;\n&#39;)

        mainUrl.close()

        # parse the result
        if len(page) == 0:
            return []

        # check that error was not returned
        for line in page:
            if line.find(&#39;Error occurred&#39;) != -1:
                raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

        result = []

        # find out if no default files.  If so, return realtime also
        hasDefault = False
        for line in page:
            items = line.split(&#39;,&#39;)
            if len(items) &lt; 4:
                continue
            if int(items[3]) == 1:
                hasDefault = True
                break

        for line in page:
            items = line.split(&#39;,&#39;)
            if len(items) &lt; 4:
                continue
            category = int(items[3])
            if hasDefault and category != 1 and not getNonDefault:
                continue
            if not hasDefault and category != 4 and not getNonDefault:
                continue
            if len(items) &gt; 6:
                doi = items[6]
            else:
                doi = None
            result.append(MadrigalExperimentFile(items[0],
                                                 items[1],
                                                 items[2],
                                                 items[3],
                                                 items[4],
                                                 items[5],
                                                 id,
                                                 doi))
            

        return result


    def getExperimentFileParameters(self,fullFilename):
        &#34;&#34;&#34; getExperimentFileParameters returns a list of all measured and derivable parameters in file

        Inputs:

           fullFilename - full path to experiment file as returned by getExperimentFiles.

        Outputs:

            List of MadrigalParameter objects for that fullFilename.  Includes both measured
            and derivable parameters in file.


        &#34;&#34;&#34;

        scriptName = &#39;getParametersService.py&#39;

        url = self.cgiurl + scriptName + &#39;?filename=%s&#39; % (str(fullFilename))


        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
        except:
            raise ValueError(&#39;unable to open url &#39; + str(url))
                

        page = mainUrl.read().decode(&#39;utf8&#39;)
        page = page.split(&#39;\n&#39;)

        mainUrl.close()

        # parse the result
        if len(page) == 0:
            return []

        # check that error was not returned
        for line in page:
            if line.find(&#39;Error occurred&#39;) != -1:
                raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

        result = []



        for line in page:
            items = line.split(&#39;\\&#39;)
            # with Madrigal 2.5, isAddIncrement was added as 8th column
            if len(items) &lt; 7:
                continue
            try:
                isAddIncrement = int(items[7])
            except:
                isAddIncrement = -1
            result.append(MadrigalParameter(items[0],
                                            items[1],
                                            int(items[2]),
                                            items[3],
                                            int(items[4]),
                                            items[5],
                                            int(items[6]),
                                            isAddIncrement))
            

        return result


    def simplePrint(self, filename, user_fullname, user_email, user_affiliation):
        &#34;&#34;&#34;simplePrint prints the data in the given file is a simple ascii format.

        simplePrint prints only the parameters in the file, without filters or derived
        parameters.  To choose which parameters to print, to print derived parameters, or
        to filter the data, use isprint instead.

        Inputs:

            filename - The absolute filename to be printed.  Returned by getExperimentFiles.

            user_fullname - full name of user making request

            user_email - email address of user making request

            user_affiliation - affiliation of user making request

        Returns: string representing all data in the file in ascii, space-delimited form.
                 The first line if the list of parameters printed.  The first six parameters will
                 always be year, month, day, hour, min, sec, representing the middle time of
                 the measurment.
        &#34;&#34;&#34;
        parms = self.getExperimentFileParameters(filename)

        parmStr = &#39;year,month,day,hour,min,sec&#39;
        labelStr = &#39;YEAR     MONTH       DAY      HOUR       MIN       SEC        &#39;

        for parm in parms:
            if parm.isMeasured and parm.isAddIncrement != 1:
                parmStr += &#39;,%s&#39; % (parm.mnemonic)
                thisLabel = parm.mnemonic[:11].upper()
                labelStr += &#39;%s%s&#39; % (thisLabel, &#39; &#39;*(11-len(thisLabel)))

        retStr = &#39;%s\n&#39; % (labelStr)

        retStr += self.isprint(filename, parmStr, &#39;&#39;, user_fullname, user_email, user_affiliation)

        return(retStr)

        

    def isprint(self, filename, parms, filters, user_fullname, user_email, user_affiliation, outputFile=None):
        &#34;&#34;&#34;returns as a string the isprint output given filename, parms, filters without headers or summary.

        Inputs:

            filename - The absolute filename to be analyzed by isprint.

            parms - Comma delimited string listing requested parameters (no spaces allowed).

            filters - Space delimited string listing filters desired, as in isprint command

            user_fullname - full name of user making request

            user_email - email address of user making request

            user_affiliation - affiliation of user making request
            
            outputFile - if not None, download the results to outputFile.  If outputFile has an extension
                of .h5, .hdf, or .hdf5, will download in Madrigal Hdf5 format.  If it has a .nc extension, will
                download as netCDF4. Otherwise, it will download as column delimited ascii.
                Trying to save as Hdf5 or netCDF4 with a Madrigal 2 site will raise an exception

        Returns:
        
            a string holding the isprint output
        &#34;&#34;&#34;
        
        scriptName = &#39;isprintService.py&#39;

        # build the complete cgi string, replacing characters as required by cgi standard

        url = self.cgiurl + scriptName + &#39;?&#39;

        
        url += &#39;file=%s&amp;&#39; % (filename.replace(&#39;/&#39;, &#39;%2F&#39;))
        if parms.find(&#39; &#39;) != -1:
            parms = parms.replace(&#39; &#39;, &#39;&#39;) # remove all spaces
        parms = parms.replace(&#39;+&#39;,&#39;%2B&#39;)
        parms = parms.replace(&#39;,&#39;,&#39;+&#39;)
        url += &#39;parms=%s&amp;&#39; % (parms)
        filters = filters.replace(&#39;=&#39;,&#39;%3D&#39;)
        filters = filters.replace(&#39;,&#39;,&#39;%2C&#39;)
        filters = filters.replace(&#39;/&#39;,&#39;%2F&#39;)
        filters = filters.replace(&#39;+&#39;,&#39;%2B&#39;)
        filters = filters.replace(&#39; &#39;,&#39;+&#39;)
        url += &#39;filters=%s&amp;&#39; % (filters)
        user_fullname = user_fullname.replace(&#39; &#39;,&#39;+&#39;).strip()
        url += &#39;user_fullname=%s&amp;&#39; % (user_fullname)
        user_email = user_email.strip()
        url += &#39;user_email=%s&amp;&#39; % (user_email)
        user_affiliation = user_affiliation.replace(&#39; &#39;,&#39;+&#39;).strip()
        url += &#39;user_affiliation=%s&#39; % (user_affiliation)
        if not outputFile is None:
            url += &#39;&amp;output=%s&#39; % (os.path.basename(outputFile))
            filename, file_extension = os.path.splitext(outputFile)
            if file_extension in (&#39;.hdf5&#39;, &#39;.h5&#39;, &#39;.hdf&#39;):
                format = &#39;Hdf5&#39;
            elif file_extension in (&#39;.nc&#39;,):
                format = &#39;netCDF4&#39;
            else:
                format = &#39;ascii&#39;
            # if Hdf5 or netCDF4, make sure site is 3 or greater
            if format in (&#39;Hdf5&#39;, &#39;netCDF4&#39;):
                version = self.getVersion()
                if distutils.version.LooseVersion(version) &lt; distutils.version.LooseVersion(&#39;3.0&#39;):
                    raise ValueError(&#39;Madrigal site at %s is below 3.0, cannot convert to Hdf5 or netCDF4&#39; % (self.cgiurl))
        else:
            format = &#39;ascii&#39;

        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT)
        except:
            raise ValueError(&#39;unable to open url &#39; + str(url))
                
        if format == &#39;ascii&#39;:
            page = mainUrl.read().decode(&#39;utf-8&#39;)
        else:
            page = mainUrl.read()

        mainUrl.close()

        if format == &#39;ascii&#39;:
            if page.find(&#39;Error occurred&#39;) != -1:
                raise ValueError(&#39;error raised using url &#39; + str(url))
    
        if outputFile is None:
            return page
        
        else:
            if format == &#39;ascii&#39;:
                f = open(outputFile, &#39;w&#39;)
            else:
                f = open(outputFile, &#39;wb&#39;)
            f.write(page)
            f.close()


    def madCalculator(self,
                      year,
                      month,
                      day,
                      hour,
                      min,
                      sec,
                      startLat,
                      endLat,
                      stepLat,
                      startLong,
                      endLong,
                      stepLong,
                      startAlt,
                      endAlt,
                      stepAlt,
                      parms,
                      oneDParmList=[],
                      oneDParmValues=[]):
        &#34;&#34;&#34;

        Input arguments:

            1. year - int 

            2. month - int 

            3. day - int
            
            4. hour - int 

            5. min - int 

            6. sec - int 

            7. startLat - Starting geodetic latitude, -90 to 90 (float)

            8. endLat - Ending geodetic latitude, -90 to 90 (float)

            9. stepLat - Latitude step (0.1 to 90) (float)

            10. startLong - Starting geodetic longitude, -180 to 180  (float)

            11. endLong - Ending geodetic longitude, -180 to 180 (float)

            12. stepLong - Longitude step (0.1 to 180) (float)

            13. startAlt - Starting geodetic altitude, &gt;= 0 (float)

            14. endAlt - Ending geodetic altitude, &gt; 0 (float)

            15. stepAlt - Altitude step (&gt;= 0.1) (float)

            16. parms - comma delimited string of Madrigal parameters desired

            17. oneDParmList - a list of one-D parameters whose values should
                               be set for the calculation.  Can be codes or mnemonics.
                               Defaults to empty list.

            18. oneDParmValues - a list of values (doubles) associated with the one-D
                                 parameters specified in oneDParmList. Defaults to empty list.

        Returns:

            A list of lists of doubles, where each list contains 3 + number of parameters doubles.
            The first three doubles are the input latitude, longitude, and altitude.  The rest of the
            doubles are the values of each of the calculated values.  If the value cannot be calculated,
            it will be set to nan.

            Example:

                result = testData.madCalculator(1999,2,15,12,30,0,45,55,5,-170,-150,10,200,200,0,&#39;bmag,bn&#39;)

                result = [  [45.0, -170.0, 200.0, 4.1315700000000002e-05, 2.1013500000000001e-05]
                            [45.0, -160.0, 200.0, 4.2336899999999998e-05, 2.03685e-05]
                            [45.0, -150.0, 200.0, 4.3856400000000002e-05, 1.97411e-05]
                            [50.0, -170.0, 200.0, 4.3913599999999999e-05, 1.9639999999999998e-05]
                            [50.0, -160.0, 200.0, 4.4890099999999999e-05, 1.8870999999999999e-05]
                            [50.0, -150.0, 200.0, 4.6337800000000002e-05, 1.80077e-05]
                            [55.0, -170.0, 200.0, 4.6397899999999998e-05, 1.78115e-05]
                            [55.0, -160.0, 200.0, 4.7265400000000003e-05, 1.6932500000000001e-05]
                            [55.0, -150.0, 200.0, 4.85495e-05,            1.5865399999999999e-05] ]

                Columns:     gdlat  glon    gdalt  bmag                    bn

        &#34;&#34;&#34;

        scriptName = &#39;madCalculatorService.py&#39;

        url = self.cgiurl + scriptName + &#39;?year&#39;

        if len(oneDParmList) != len(oneDParmValues):
            raise ValueError(&#39;len(oneDParmList) != len(oneDParmValues)&#39;)
        
        if parms.find(&#39; &#39;) != -1:
            parms = parms.replace(&#39; &#39;, &#39;&#39;) # remove all spaces

        # append arguments
        url += &#39;=%i&amp;month&#39; % (int(year))
        url += &#39;=%i&amp;day&#39; % (int(month))
        url += &#39;=%i&amp;hour&#39; % (int(day))
        url += &#39;=%i&amp;min&#39; % (int(hour))
        url += &#39;=%i&amp;sec&#39; % (int(min))
        url += &#39;=%i&amp;startLat&#39; % (int(sec))
        url += &#39;=%f&amp;endLat&#39; % (float(startLat))
        url += &#39;=%f&amp;stepLat&#39; % (float(endLat))
        url += &#39;=%f&amp;startLong&#39; % (float(stepLat))
        url += &#39;=%f&amp;endLong&#39; % (float(startLong))
        url += &#39;=%f&amp;stepLong&#39; % (float(endLong))
        url += &#39;=%f&amp;startAlt&#39; % (float(stepLong))
        url += &#39;=%f&amp;endAlt&#39; % (float(startAlt))
        url += &#39;=%f&amp;stepAlt&#39; % (float(endAlt))
        url += &#39;=%f&amp;parms&#39; % (float(stepAlt))
        url += &#39;=%s&#39; % (parms)

        for i in range(len(oneDParmList)):
            url += &#39;&amp;oneD=%s,%s&#39; % (str(oneDParmList[i]), str(oneDParmValues[i]))
            
        # remove any pluses in the url due to scientific notation
        url = url.replace(&#39;+&#39;, &#39;%2B&#39;)

        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT)
        except:
            raise ValueError(&#39;unable to open url &#39; + str(url))
                

        page = mainUrl.read().decode(&#39;utf8&#39;)
        page = page.split(&#39;\n&#39;)

        mainUrl.close()

        # parse the result
        if len(page) == 0:
            raise ValueError(&#39;No data found at url&#39; + str(url))

        # check that error was not returned
        for line in page:
            if line.find(&#39;Error occurred&#39;) != -1:
                raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

        result = []

        # parse output
        for line in page:
            items = line.split()
            if len(items) &lt; 3:
                # blank line
                continue
            newList = []
            for item in items:
                try:
                    newList.append(float(item))
                except:
                    newList.append(str(item))
            result.append(newList)

        return result
    
    
    def madCalculator2(self,
                      year,
                      month,
                      day,
                      hour,
                      min,
                      sec,
                      latList,
                      lonList,
                      altList,
                      parms,
                      oneDParmList=[],
                      oneDParmValues=[],
                      twoDParmList = [],
                      twoDParmValues = []):
        &#34;&#34;&#34;
        madCalculator2 is similar to madCalculator, except that a random collection of points in space can be specified,
        rather than a grid of points.  Also, a user can input 2D data.
        
        Added to Madrigal2.6 as web service - will not run on earlier Madrigal installations.

        Input arguments:

            1. year - int 

            2. month - int 

            3. day - int
            
            4. hour - int 

            5. min - int 

            6. sec - int 

            7. latList - a list of geodetic latitudes, -90 to 90

            8. lonList - a list of longitudes, -180 to 180. Length must = lats
            
            9. altList - a list of geodetic altitudes in km. Length must = lats

            10. parms - comma delimited string of Madrigal parameters desired

            11. oneDParmList - a list of one-D parameters whose values should
                               be set for the calculation.  Can be codes or mnemonics.
                               Defaults to empty list.

            12. oneDParmValues - a list of values (doubles) associated with the one-D
                                 parameters specified in oneDParmList. Defaults to empty list.
                                 
            13. twoDParmList - a python list of two-D parameters as mnemonics.  Defaults to [].
            
            14. twoDParmValues - a python list of lists of len = len(twoDParmList). Each individual 
                             list is a list of doubles representing values of the two-D
                             parameter set in twoDParmList, with a length = number 
                             of points (or equal to len(lats)). Defaults to [].

        Returns:

            A list of lists of doubles, where each list contains 3 + number of parameters doubles.
            The first three doubles are the input latitude, longitude, and altitude.  The rest of the
            doubles are the values of each of the calculated values.  If the value cannot be calculated,
            it will be set to nan.

            Example:

                result = testData.madCalculator2(1999,2,15,12,30,0,[45,55],[-170,-150],[200,300],&#39;sdwht,kp&#39;)

                result = [ [1999.0, 2.0, 15.0, 12.0, 30.0, 0.0, 3.0, 15.0]
                           [1999.0, 2.0, 15.0, 12.0, 45.0, 0.0, 3.0, 15.0]
                           [1999.0, 2.0, 15.0, 13.0, 0.0, 0.0, 3.0, 15.0]
                           [1999.0, 2.0, 15.0, 13.0, 15.0, 0.0, 3.0, 15.0] ]


                Columns:     gdlat  glon    gdalt  sdwht   kp
                
        Now uses POST to avoid long url issue

    &#34;&#34;&#34;
    
        # verify Madrigal site can call this command
        if self.compareVersions(&#39;2.6&#39;, self._madVers):
            raise IOError(&#39;madCalculator2 requires Madrigal 2.6 or greater, but this site is version %s&#39; % (self._madVers))

        scriptName = &#39;madCalculator2Service.py&#39;
        
        if parms.find(&#39; &#39;) != -1:
            parms = parms.replace(&#39; &#39;, &#39;&#39;) # remove all spaces

        url = self.cgiurl + scriptName
        

        # error checking
        if len(oneDParmList) != len(oneDParmValues):
            raise ValueError(&#39;len(oneDParmList) != len(oneDParmValues)&#39;)
        
        if len(latList) == 0:
            raise ValueError(&#39;length of latList must be at least one&#39;)
        
        if len(latList) != len(lonList) or len(latList) != len(altList):
            raise ValueError(&#39;lengths of latList, lonList, altList must all be equal&#39;)
        
        if len(oneDParmList) != len(oneDParmValues):
            raise ValueError(&#39;len(oneDParmList) != len(oneDParmValues)&#39;)
        
        postUrl = &#39;year&#39;
        # append arguments
        delimiter = &#39;,&#39;
        postUrl += &#39;=%i&amp;month&#39; % (int(year))
        postUrl += &#39;=%i&amp;day&#39; % (int(month))
        postUrl += &#39;=%i&amp;hour&#39; % (int(day))
        postUrl += &#39;=%i&amp;min&#39; % (int(hour))
        postUrl += &#39;=%i&amp;sec&#39; % (int(min))
        postUrl += &#39;=%i&amp;lats=&#39; % (int(sec))
        for i in range(len(latList)):
            postUrl += str(latList[i])
            if i + 1 &lt; len(latList):
                postUrl += &#39;,&#39;
        postUrl += &#39;&amp;longs=&#39;
        for i in range(len(lonList)):
            postUrl += str(lonList[i])
            if i + 1 &lt; len(lonList):
                postUrl += &#39;,&#39;
        postUrl += &#39;&amp;alts=&#39;
        for i in range(len(altList)):
            postUrl += str(altList[i])
            if i + 1 &lt; len(altList):
                postUrl += &#39;,&#39;
        postUrl += &#39;&amp;parms=%s&#39; % (parms)

        for i in range(len(oneDParmList)):
            postUrl += &#39;&amp;oneD=%s,%s&#39; % (str(oneDParmList[i]), str(oneDParmValues[i]))
            
        for i in range(len(twoDParmList)):
            postUrl += &#39;&amp;twoD=%s,&#39; % (str(twoDParmList[i]))
            for j in range(len(twoDParmValues[i])):
                postUrl += str(twoDParmValues[i][j])
                if j + 1 &lt; len(twoDParmValues[i]):
                    postUrl += &#39;,&#39;
                    
        # remove any pluses in the url due to scientific notation
        postUrl = postUrl.replace(&#39;+&#39;, &#39;%2B&#39;)
            
        data = postUrl.encode(&#34;utf-8&#34;)

        # read main url
        try:
            req = urllib2.Request(url)
            response = urllib2.urlopen(req, data=data, timeout=TIMEOUT)
        except:
            raise ValueError(&#39;unable to open url &#39; + str((url, postUrl)))
                

        page = response.read().decode(&#39;utf8&#39;)
        page = page.split(&#39;\n&#39;)

        response.close()

        # parse the result
        if len(page) == 0:
            raise ValueError(&#39;No data found at url&#39; + str(url))

        # check that error was not returned
        for line in page:
            if line.find(&#39;Error occurred&#39;) != -1:
                raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

        result = []

        # parse output
        for line in page:
            items = line.split()
            if len(items) &lt; 3:
                # blank line
                continue
            newList = []
            for item in items:
                try:
                    newList.append(float(item))
                except:
                    newList.append(str(item))
            result.append(newList)

        return result
    
    
    def madCalculator3(self,
                      yearList,
                      monthList,
                      dayList,
                      hourList,
                      minList,
                      secList,
                      latList,
                      lonList,
                      altList,
                      parms,
                      oneDParmList=[],
                      oneDParmValues=[],
                      twoDParmList = [],
                      twoDParmValues = []):
        &#34;&#34;&#34;
        madCalculator3 is similar to madCalculator, except that multiple times can be specified,
        where each time can have its own unique spatial positions and 1D and 2D parms. It is
        equivalent to multiple calls to madCalculator2, except that it should greatly improve 
        performance where multiple calls to madCalculator2 are required for different times.
        The only restriction is that the same parameters must be requested for every time.
        
        Added to Madrigal2.6 as web service - will not run on earlier Madrigal installations.
        
        Now uses POST to send arguments, due to large volume of data possible

        Input arguments:

            1. yearList - a list of years, one for each time requested (ints)

            2. monthList - a list of months, one for each time requested. (ints)

            3. dayList - a list of days, one for each time requested. (ints)
            
            4. hourList - a list of hours, one for each time requested. (ints)

            5. minList - a list of minutes, one for each time requested. (ints)

            6. secList - a list of seconds, one for each time requested. (ints)

            7. latList - a list of lists of geodetic latitudes, -90 to 90.  The
               first list is for the first time, the second for the second time, etc.
               The list do not need to have the same number of points.  The number
               of times must match yearList.
               Data organization: latList[timeIndex][positionIndex]

            8. lonList - a list of lists of longitudes, -180 to 180. The
               first list is for the first time, the second for the second time, etc.
               The list do not need to have the same number of points.  The number
               of times must match yearList. Lens must match latList
               Data organization: lonList[timeIndex][positionIndex]
            
            9. altList - a list of lists of geodetic altitudes in km. The
               first list is for the first time, the second for the second time, etc.
               The list do not need to have the same number of points.  The number
               of times must match yearList. Lens must match latList
               Data organization: altList[timeIndex][positionIndex]

            10. parms - comma delimited string of Madrigal parameters desired

            11. oneDParmList - a list of one-D parameters whose values should
                               be set for the calculation.  Can be codes or mnemonics.
                               Defaults to empty list.

            12. oneDParmValues - a list of lists of values (doubles) associated with the one-D
                                 parameters specified in oneDParmList. Defaults to empty list.
                                 The first list is for the first 1D parameter in oneDParmList,
                                 and must be on length len(yearList).  The second list is for 
                                 the second parameter, etc. 
                                 Data organization: onDParmValues[parameterIndex][timeIndex]
                                 
            13. twoDParmList - a python list of of two-D parameters as mnemonics.  Defaults to [].
            
            14. twoDParmValues - a list of lists of lists of values (doubles) associated with the two-D
                                 parameters specified in twoDParmList. Defaults to empty list.
                                 The first list is for the first 2D parameter in oneDParmList,
                                 and must be a list of length len(yearList).  Each list in that
                                 list must be of len(num positions for that time). The second list is for 
                                 the second parameter, etc. 
                                 Data organization: twoDParmValues[parameterIndex][timeIndex][positionIndex]

        Returns:

            A list of lists of doubles, where each list contains 9 + number of parameters doubles.
            The first nine doubles are:
            1) year, 2) month, 3) day, 4) hour, 5) minute, 6) second,
            7) input latitude, 8) longitude, and 9) altitude.  
            The rest of the doubles are the values of each of the calculated values.  If the value 
            cannot be calculated, it will be set to nan.

            Example:

                testData.madCalculator3(yearList=[2001,2001], monthList=[3,3], dayList=[19,20],
                                     hourList=[12,12], minList=[30,40], secList=[20,0],
                                     latList=[[45,46,47,48.5],[46,47,48.2,49,50]],
                                     lonList=[[-70,-71,-72,-73],[-70,-71,-72,-73,-74]],
                                     altList=[[145,200,250,300.5],[200,250,300,350,400]],
                                     parms=&#39;bmag,pdcon,ne_model&#39;,
                                     oneDParmList=[&#39;kinst&#39;,&#39;elm&#39;],
                                     oneDParmValues=[[31.0,31.0],[45.0,50.0]],
                                     twoDParmList=[&#39;ti&#39;,&#39;te&#39;,&#39;ne&#39;],
                                     twoDParmValues=[[[1000,1000,1000,1000],[1000,1000,1000,1000,1000]],
                                                     [[1100,1200,1300,1400],[1500,1000,1100,1200,1300]],
                                                     [[1.0e10,1.0e10,1.0e10,1.0e10],[1.0e10,1.0e10,1.0e10,1.0e10,1.0e10]]])


                Columns:     year month day hour minute second gdlat  glon  gdalt  bmag  pdcon  ne_model

    &#34;&#34;&#34;
        # verify Madrigal site can call this command
        if self.compareVersions(&#39;2.6&#39;, self._madVers):
            raise IOError(&#39;madCalculator3 requires Madrigal 2.6 or greater, but this site is version %s&#39; % (self._madVers))


        scriptName = &#39;madCalculator3Service.py&#39;

        url = self.cgiurl + scriptName
        
        postUrl = &#39;&#39;

        # error checking
        try:
            totalTimes = len(yearList)
        except:
            raise ValueError(&#39;yearList must be a list, not %s&#39; % (str(yearList)))
        
        if len(monthList) != totalTimes or \
           len(dayList) != totalTimes or \
           len(hourList) != totalTimes or \
           len(minList) != totalTimes or \
           len(secList) != totalTimes:
            raise ValueError(&#39;Not all time lists have same length&#39;)
        
        if parms.find(&#39; &#39;) != -1:
            parms = parms.replace(&#39; &#39;, &#39;&#39;) # remove all spaces
        
        # add time arguments
        postUrl += &#39;year=&#39;
        for i, year in enumerate(yearList):
            postUrl += &#39;%i&#39; % (year)
            if i+1 &lt; len(yearList):
                postUrl += &#39;,&#39;
                
        postUrl += &#39;&amp;month=&#39;
        for i, month in enumerate(monthList):
            postUrl += &#39;%i&#39; % (month)
            if i+1 &lt; len(monthList):
                postUrl += &#39;,&#39;
        
        postUrl += &#39;&amp;day=&#39;
        for i, day in enumerate(dayList):
            postUrl += &#39;%i&#39; % (day)
            if i+1 &lt; len(dayList):
                postUrl += &#39;,&#39;
        
        postUrl += &#39;&amp;hour=&#39;
        for i, hour in enumerate(hourList):
            postUrl += &#39;%i&#39; % (hour)
            if i+1 &lt; len(hourList):
                postUrl += &#39;,&#39;
                
        postUrl += &#39;&amp;min=&#39;
        for i, minute in enumerate(minList):
            postUrl += &#39;%i&#39; % (minute)
            if i+1 &lt; len(minList):
                postUrl += &#39;,&#39;
                
        postUrl += &#39;&amp;sec=&#39;
        for i, sec in enumerate(secList):
            postUrl += &#39;%i&#39; % (sec)
            if i+1 &lt; len(secList):
                postUrl += &#39;,&#39;
                
        # get numPos list from latList
        numPos = []
        for lats in latList:
            numPos.append(len(lats))
            
        postUrl += &#39;&amp;numPos=&#39;
        for i, pos in enumerate(numPos):
            postUrl += &#39;%i&#39; % (pos)
            if i+1 &lt; len(numPos):
                postUrl += &#39;,&#39;
                
        postUrl += &#39;&amp;lats=&#39;
        for i, posList in enumerate(latList):
            if len(posList) != numPos[i]:
                raise ValueError(&#39;mismatched number of points in latList&#39;)
            for j, pos in enumerate(posList):
                postUrl += &#39;%f&#39; % (pos)
                if i+1 &lt; len(latList) or j+1 &lt; len(posList):
                    postUrl += &#39;,&#39;
                    
        postUrl += &#39;&amp;longs=&#39;
        for i, posList in enumerate(lonList):
            if len(posList) != numPos[i]:
                raise ValueError(&#39;mismatched number of points in lonList&#39;)
            for j, pos in enumerate(posList):
                postUrl += &#39;%f&#39; % (pos)
                if i+1 &lt; len(lonList) or j+1 &lt; len(posList):
                    postUrl += &#39;,&#39;
                    
        postUrl += &#39;&amp;alts=&#39;
        for i, posList in enumerate(altList):
            if len(posList) != numPos[i]:
                raise ValueError(&#39;mismatched number of points in altList&#39;)
            for j, pos in enumerate(posList):
                postUrl += &#39;%f&#39; % (pos)
                if i+1 &lt; len(altList) or j+1 &lt; len(posList):
                    postUrl += &#39;,&#39;
                    
        postUrl += &#39;&amp;parms=%s&#39; % (parms)
                                                                  
        if len(oneDParmList) != len(oneDParmValues):
            raise ValueError(&#39;len(oneDParmList) != len(oneDParmValues)&#39;)

        for i, parm in enumerate(oneDParmList):
            postUrl += &#39;&amp;oneD=%s,&#39; % (str(parm))
            if len(oneDParmValues[i]) != totalTimes:
                raise ValueError(&#39;wrong number of 1D parms for %s&#39; % (str(parm)))
            for j, value in enumerate(oneDParmValues[i]):
                postUrl += &#39;%f&#39; % (value)
                if j+1 &lt; len(oneDParmValues[i]):
                    postUrl += &#39;,&#39;
                    
        for i, parm in enumerate(twoDParmList):
            postUrl += &#39;&amp;twoD=%s,&#39; % (str(parm))
            if len(twoDParmValues[i]) != totalTimes:
                raise ValueError(&#39;wrong number of 2D parms for %s&#39; % (str(parm)))
            for j, valueList in enumerate(twoDParmValues[i]):
                if len(valueList) != numPos[j]:
                    raise ValueError(&#39;wrong number of 2D parms for %s&#39; % (str(parm)))
                for k, value in enumerate(valueList):
                    postUrl += &#39;%f&#39; % (value)
                    if j+1 &lt; len(twoDParmValues[i]) or k+1 &lt; len(valueList):
                        postUrl += &#39;,&#39;  
                        
        # remove any pluses in the url due to scientific notation
        postUrl = postUrl.replace(&#39;+&#39;, &#39;%2B&#39;)
                 
        data = postUrl.encode(&#39;utf8&#39;)

        # read main url
        try:
            req = urllib2.Request(url)
            response = urllib2.urlopen(req, data=data, timeout=TIMEOUT)
        except:
            raise ValueError(&#39;unable to open url &#39; + str((url, postUrl)))
                

        page = response.read().decode(&#39;utf8&#39;)
        page = page.split(&#39;\n&#39;)

        response.close()

        # parse the result
        if len(page) == 0:
            raise ValueError(&#39;No data found at url&#39; + str(url))

        # check that error was not returned
        for line in page:
            if line.find(&#39;Error occurred&#39;) != -1:
                raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

        result = []
        
        # time data to add to each line
        year=None
        month=None
        day=None
        hour=None
        minute=None
        second=None
        
        for line in page:
            items = line.split()
            if len(items) &lt; 3:
                # blank line
                continue
            if line.find(&#39;TIME&#39;) != -1:
                # new time found
                dates=items[1].split(&#39;/&#39;)
                year = int(dates[2])
                month = int(dates[0])
                day = int(dates[1])
                times=items[2].split(&#39;:&#39;)
                hour = int(times[0])
                minute = int(times[1])
                second = int(times[2])
                continue
            newList = [year,month,day,hour,minute,second]
            for item in items:
                try:
                    newList.append(float(item))
                except:
                    newList.append(str(item))
            result.append(newList)

        return result


    def madTimeCalculator(self,
                          startyear,
                          startmonth,
                          startday,
                          starthour,
                          startmin,
                          startsec,
                          endyear,
                          endmonth,
                          endday,
                          endhour,
                          endmin,
                          endsec,
                          stephours,
                          parms):
        &#34;&#34;&#34;

        Input arguments:

            1. startyear - int 

            2. startmonth - int 

            3. startday - int
            
            4. starthour - int 

            5. startmin - int 

            6. startsec - int

            7. endyear - int 

            8. endmonth - int 

            9. endday - int
            
            10. endhour - int 

            11. endmin - int 

            12. endsec - int

            13. stephours - float - number of hours per time step

            14. parms - comma delimited string of Madrigal parameters desired (must not depend on location)

        Returns:

            A list of lists, where each list contains 6 ints (year, month, day, hour, min, sec)  + number
            of parameters.  If the value cannot be calculated, it will be set to nan.

            Example:

                result = testData.madTestCalculator(1999,2,15,12,30,0,
                                                    1999,2,20,12,30,0,
                                                    24.0, &#39;kp,dst&#39;)

                result = [[1999.0, 2.0, 15.0, 12.0, 30.0, 0.0, 3.0, -9.0]
                          [1999.0, 2.0, 16.0, 12.0, 30.0, 0.0, 1.0, -6.0]
                          [1999.0, 2.0, 17.0, 12.0, 30.0, 0.0, 4.0, -31.0]
                          [1999.0, 2.0, 18.0, 12.0, 30.0, 0.0, 6.7000000000000002, -93.0]
                          [1999.0, 2.0, 19.0, 12.0, 30.0, 0.0, 5.2999999999999998, -75.0]]

                Columns:     year, month, day, hour, min, sec, kp, dst

        &#34;&#34;&#34;

        scriptName = &#39;madTimeCalculatorService.py&#39;

        url = self.cgiurl + scriptName + &#39;?startyear&#39;
        
        if parms.find(&#39; &#39;) != -1:
            parms = parms.replace(&#39; &#39;, &#39;&#39;) # remove all spaces

        # append arguments
        url += &#39;=%i&amp;startmonth&#39; % (int(startyear))
        url += &#39;=%i&amp;startday&#39; % (int(startmonth))
        url += &#39;=%i&amp;starthour&#39; % (int(startday))
        url += &#39;=%i&amp;startmin&#39; % (int(starthour))
        url += &#39;=%i&amp;startsec&#39; % (int(startmin))
        url += &#39;=%i&amp;endyear&#39; % (int(startsec))
        url += &#39;=%i&amp;endmonth&#39; % (int(endyear))
        url += &#39;=%i&amp;endday&#39; % (int(endmonth))
        url += &#39;=%i&amp;endhour&#39; % (int(endday))
        url += &#39;=%i&amp;endmin&#39; % (int(endhour))
        url += &#39;=%i&amp;endsec&#39; % (int(endmin))
        url += &#39;=%i&amp;stephours&#39; % (int(endsec))
        url += &#39;=%f&amp;parms&#39; % (float(stephours))
        url += &#39;=%s&#39; % (parms)
        
        # remove any pluses in the url due to scientific notation
        url = url.replace(&#39;+&#39;, &#39;%2B&#39;)

        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT)
        except:
            raise ValueError(&#39;unable to open url &#39; + str(url))
                

        page = mainUrl.read().decode(&#39;utf8&#39;)
        page = page.split(&#39;\n&#39;)

        mainUrl.close()

        # parse the result
        if len(page) == 0:
            raise ValueError(&#39;No data found at url&#39; + str(url))

        # check that error was not returned
        for line in page:
            if line.find(&#39;Error occurred&#39;) != -1:
                raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

        result = []

        # parse output
        for line in page:
            items = line.split()
            if len(items) &lt; 3:
                # blank line
                continue
            newList = []
            for item in items:
                try:
                    newList.append(float(item))
                except:
                    newList.append(str(item))
            result.append(newList)

        return result



    def radarToGeodetic(self,
                        slatgd,
                        slon,
                        saltgd,
                        az,
                        el,
                        radarRange):
        &#34;&#34;&#34;radarToGeodetic converts arrays of az, el, and ranges to geodetic locations.

        Input arguments:

            1. slatgd - radar geodetic latitude 

            2. slon - radar longitude 

            3. saltgd - radar altitude
            
            4. az - either a single azimuth, or a list of azimuths 

            5. el - either a single elevation, or a list of elevations.  If so, len(el)
                    must = len(az)

            6. radarRange - either a single range, or a list of ranges.  If so, len(radarRange)
                            must = len(az)


        Returns:

            A list of lists, where each list contains 3 floats (gdlat, glon, and gdalt)
        &#34;&#34;&#34;
        scriptName = &#39;radarToGeodeticService.py&#39;

        url = self.cgiurl + scriptName + &#39;?slatgd&#39;

        # append arguments
        url += &#39;=%f&amp;slon&#39; % (float(slatgd))
        url += &#39;=%f&amp;saltgd&#39; % (float(slon))
        url += &#39;=%f&amp;&#39; % (float(saltgd))

        if type(az) == list or type(az) == tuple:
            if len(az) != len(el) or len(az) != len(radarRange):
                raise ValueError(&#39;all lists most have same length&#39;)
            for i in range(len(az)):
                if i == 0:
                    arg = str(az[i])
                else:
                    arg += &#39;,&#39; + str(az[i])
            url += &#39;az=%s&amp;&#39; % (arg)

            for i in range(len(el)):
                if i == 0:
                    arg = str(el[i])
                else:
                    arg += &#39;,&#39; + str(el[i])
            url += &#39;el=%s&amp;&#39; % (arg)

            for i in range(len(radarRange)):
                if i == 0:
                    arg = str(radarRange[i])
                else:
                    arg += &#39;,&#39; + str(radarRange[i])
            url += &#39;range=%s&#39; % (arg)

        else:
            url += &#39;az=%f&amp;&#39; % (az)
            url += &#39;el=%f&amp;&#39; % (el)
            url += &#39;range=%f&amp;&#39; % (radarRange)
            
        # remove any pluses in the url due to scientific notation
        url = url.replace(&#39;+&#39;, &#39;%2B&#39;)

        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
        except:
            raise ValueError(&#39;unable to open url &#39; + str(url))
                
        page = mainUrl.read().decode(&#39;utf8&#39;)
        page = page.split(&#39;\n&#39;)

        mainUrl.close()

        # parse the result
        if len(page) == 0:
            raise ValueError(&#39;No data found at url&#39; + str(url))

        # check that error was not returned
        for line in page:
            if line.find(&#39;Error occurred&#39;) != -1:
                raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

        result = []

        # parse output
        for line in page:
            items = line.split(&#39;,&#39;)
            if len(items) &lt; 3:
                # blank line
                continue
            newList = []
            for item in items:
                try:
                    newList.append(float(item))
                except:
                    newList.append(str(item))
            result.append(newList)

        return result


    def geodeticToRadar(self,
                        slatgd,
                        slon,
                        saltgd,
                        gdlat,
                        glon,
                        gdalt):
        &#34;&#34;&#34;geodeticToRadar converts arrays of points in space to az, el, and range.

        Input arguments:

            1. slatgd - radar geodetic latitude 

            2. slon - radar longitude 

            3. saltgd - radar altitude
            
            4. gdlat - either a single geodetic latitude, or a list of geodetic latitudes 

            5. glon - either a single longitude, or a list of longitudes.  If so, len(gdlat)
                      must = len(glon)

            6. gdalt - either a single deodetic altitude, or a list of geodetic altitudes.
                       If so, len(gdalt) must = len(gdlat)


        Returns:

            A list of lists, where each list contains 3 floats (az, el, and range)
        &#34;&#34;&#34;
        scriptName = &#39;geodeticToRadarService.py&#39;

        url = self.cgiurl + scriptName + &#39;?slatgd&#39;

        # append arguments
        url += &#39;=%f&amp;slon&#39; % (float(slatgd))
        url += &#39;=%f&amp;saltgd&#39; % (float(slon))
        url += &#39;=%f&amp;&#39; % (float(saltgd))

        if type(gdlat) == list or type(gdlat) == tuple:
            if len(gdlat) != len(glon) or len(gdlat) != len(gdalt):
                raise ValueError(&#39;all lists most have same length&#39;)
            for i in range(len(gdlat)):
                if i == 0:
                    arg = str(gdlat[i])
                else:
                    arg += &#39;,&#39; + str(gdlat[i])
            url += &#39;gdlat=%s&amp;&#39; % (arg)

            for i in range(len(glon)):
                if i == 0:
                    arg = str(glon[i])
                else:
                    arg += &#39;,&#39; + str(glon[i])
            url += &#39;glon=%s&amp;&#39; % (arg)

            for i in range(len(gdalt)):
                if i == 0:
                    arg = str(gdalt[i])
                else:
                    arg += &#39;,&#39; + str(gdalt[i])
            url += &#39;gdalt=%s&#39; % (arg)

        else:
            url += &#39;gdlat=%f&amp;&#39; % (gdlat)
            url += &#39;glon=%f&amp;&#39; % (glon)
            url += &#39;gdalt=%f&amp;&#39; % (gdalt)
            
        # remove any pluses in the url due to scientific notation
        url = url.replace(&#39;+&#39;, &#39;%2B&#39;)

        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
        except:
            raise ValueError(&#39;unable to open url &#39; + str(url))
                
        page = mainUrl.read().decode(&#39;utf8&#39;)
        page = page.split(&#39;\n&#39;)

        mainUrl.close()

        # parse the result
        if len(page) == 0:
            raise ValueError(&#39;No data found at url&#39; + str(url))

        # check that error was not returned
        for line in page:
            if line.find(&#39;Error occurred&#39;) != -1:
                raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

        result = []

        # parse output
        for line in page:
            items = line.split(&#39;,&#39;)
            if len(items) &lt; 3:
                # blank line
                continue
            newList = []
            for item in items:
                try:
                    newList.append(float(item))
                except:
                    newList.append(str(item))
            result.append(newList)

        return result


    def downloadFile(self, filename, destination, user_fullname, user_email, user_affiliation, 
                     format=&#39;simple&#39;):
        &#34;&#34;&#34;downloadFile will download a Cedar file in the specified format.

        Inputs:

            filename - The absolute filename to as returned via getExperimentFiles.

            destination - where the file is to be stored
            
            user_fullname - full name of user making request

            user_email - email address of user making request

            user_affiliation - affiliation of user making request

            format - file format desired.  May be  &#39;simple&#39;, &#39;hdf5&#39;, &#39;netCDF4&#39;,
                &#39;madrigal&#39;, &#39;blockedBinary&#39;, &#39;ncar&#39;,
                 &#39;unblockedBinary&#39;, or &#39;ascii&#39;.  Default is &#39;simple&#39;
                 Simple is a simple ascii space delimited column format.
                 Simple and hdf5 are recommended since they are standard formats
                     
                hdf5 format works for Madrigal 2.6 or later
                netCDF4 format works for Madrigal 3.0 or later
                madrigal&#39;, &#39;blockedBinary&#39;, &#39;ncar&#39;,
                 &#39;unblockedBinary&#39;, or &#39;ascii&#39; no longer supported for Madrigal 3.

        &#34;&#34;&#34;
        fileType = 0
        if format not in (&#39;hdf5&#39;, &#39;madrigal&#39;, &#39;blockedBinary&#39;, &#39;ncar&#39;, 
                          &#39;unblockedBinary&#39;, &#39;ascii&#39;, &#39;simple&#39;, &#39;netCDF4&#39;):
            raise ValueError(&#39;Illegal format specified: %s&#39; % (str(format)))
        if format == &#39;blockedBinary&#39;:
            fileType = 1
        elif format == &#39;ncar&#39;:
            fileType = 2
        elif format == &#39;unblockedBinary&#39;:
            fileType = 3
        elif format == &#39;simple&#39;:
            fileType = -1
        elif format == &#39;hdf5&#39;:
            # verify Madrigal site can handle this argument
            if self.compareVersions(&#39;2.6&#39;, self._madVers):
                raise IOError(&#39;downloadFile with hdf5 format requires Madrigal 2.6 or greater, but this site is version %s&#39; % (self._madVers))
            fileType = -2
        elif format == &#39;netCDF4&#39;:
            # verify Madrigal site can handle this argument
            if self.compareVersions(&#39;3.0&#39;, self._madVers):
                raise IOError(&#39;downloadFile with netCDF4 format requires Madrigal 3.0 or greater, but this site is version %s&#39; % (self._madVers))
            fileType = -3
        else:
            fileType = 4
            
        # verify no old formats specified if Madrigal 3
        if fileType &gt; 0:
            if not self.compareVersions(&#39;3.0&#39;, self._madVers):
                raise IOError(&#39;Only Madrigal 2.X sites can create old style files, but this site is version %s&#39; % (self._madVers))

        
        url = urlparse.urljoin(self.cgiurl,&#39;getMadfile.cgi?fileName=%s&amp;fileType=%i&amp;&#39; % (filename, fileType))
        user_fullname = user_fullname.replace(&#39; &#39;,&#39;+&#39;).strip()
        url += &#39;user_fullname=%s&amp;&#39; % (user_fullname)
        user_email = user_email.strip()
        url += &#39;user_email=%s&amp;&#39; % (user_email)
        user_affiliation = user_affiliation.replace(&#39; &#39;,&#39;+&#39;).strip()
        url += &#39;user_affiliation=%s&#39; % (user_affiliation)
        
        CHUNK = 16 * 1024

        urlFile = urllib2.urlopen(url, timeout=TIMEOUT)
        
        if format in (&#39;ascii&#39;, &#39;simple&#39;):
            f = open(destination, &#39;w&#39;)
        else:
            f = open(destination, &#39;wb&#39;)

        while(True):
            if format in (&#39;ascii&#39;, &#39;simple&#39;):
                try:
                    data = urlFile.read(CHUNK).decode(&#39;utf8&#39;)
                except:
                    # probably gzip ascii - convert
                    f.close()
                    try:
                        os.remove(destination)
                    except:
                        pass
                    urlFile.close()
                    urlFile = urllib2.urlopen(url, timeout=TIMEOUT)
                    f = open(destination + &#39;.gz&#39;, &#39;wb&#39;)
                    format = &#39;gzip&#39;
                    data = urlFile.read(CHUNK)
                    
            else:
                data = urlFile.read(CHUNK)
            if not data:
                break
            f.write(data)
            
        urlFile.close()
        
        f.close()
        
        
    
    def listFileTimes(self, expDir=None):
        &#34;&#34;&#34;listFileTimes lists the filenames and last modification times for all files in a Madrigal database.

        Inputs: expDir - experiment directory to which to start.  May be any directory or subdirectory below 
            experiments[0-9]*.  Path may be absolute or relative to experiments[0-9]*.  If None (the default),
            include entire experiments[0-9]* directory(s).  Examples: (&#39;/opt/madrigal/experiments/1998&#39;,
            &#39;experiments/2002/gps&#39;)
            
        Returns: a list of tuple of 1. filename relative to experiments[0-9]* directory, and 2) datetime in UT of 
            last file modification
            
        Requires:  Madrigal 2.6 or greater
        &#34;&#34;&#34;
        # verify Madrigal site can call this command
        if self.compareVersions(&#39;2.6&#39;, self._madVers):
            raise IOError(&#39;listFileTimes requires Madrigal 2.6 or greater, but this site is version %s&#39; % (self._madVers))
    
        url = urlparse.urljoin(self.cgiurl,&#39;listFileTimesService.py&#39;)
        
        if expDir:
            url += &#39;?expDir=%s&#39; % (expDir)

        urlFile = urllib2.urlopen(url, timeout=TIMEOUT)
        
        retList = []

        data = urlFile.read().decode(&#39;utf-8&#39;)
        lines = data.split(&#39;\n&#39;)
        for line in lines:
            items = line.split(&#39;,&#39;)
            if len(items) != 2:
                continue
            filename = items[0].strip()[1:-1] # strip off quotes
            dt = datetime.datetime.strptime(items[1].strip(), &#39;%Y-%m-%d %H:%M:%S&#39;)
            retList.append((filename, dt))
            
        return(retList)
    
    
    def downloadWebFile(self, expPath, destination):
        &#34;&#34;&#34;downloadWebFile allows a user to download a axillary file from the web site. Used to
        download files found by listFileTimes.
        
        Requires a Madrigal 3.0 site.
        
        Inputs:
            expPath - filename relative to experiments[0-9]* directory. As returned by listFileTimes.
            destination - path to save file to
        &#34;&#34;&#34;
        # verify Madrigal site can call this command
        if self.compareVersions(&#39;3.0&#39;, self._madVers):
            raise IOError(&#39;downloadWebFile requires Madrigal 3.0 or greater, but this site is version %s&#39; % (self._madVers))
        
        url = urlparse.urljoin(self.cgiurl,&#39;downloadWebFileService.py&#39;)
        
        url += &#39;?expPath=%s&#39; % (expPath.replace(&#39; &#39;, &#39;+&#39;))
        
        urlFile = urllib2.urlopen(url, timeout=TIMEOUT2)

        data = urlFile.read()

        urlFile.close()
        
        f = open(destination, &#39;wb&#39;)

        f.write(data)

        f.close()
        
        
        
        
    def traceMagneticField(self, year, month, day, hour, minute,second,
                           inputType, outputType, alts, lats, lons,
                           model, qualifier, stopAlt=None):
        &#34;&#34;&#34;
        traceMagneticField returns a point along a magnetic field line for each
        point specified by the lists alts, lats, lons.
        Traces to either 1) conjugate point, 2) intersection with a given altitude in the
        northern or southern hemisphere, 3) to the apex, or 4) to GSM XY plane, depending on qualifier
        argument.  Uses Tsyganenko or IGRF fields, depending on model argument.
        Input arguments are either GSM or Geodetic, depending on inputType argument.
        Output arguments are either GSM or Geodetic, depending on outputType
        argument.

        Inputs:
        
            year, month, day, hour, minute, second - time at which to do the trace

            inputType  - 0 for geodetic, 1 for GSM

            outputType - 0 for geodetic, 1 for GSM
        
            The following parameter depend on inputType:
            
            alts - a list of geodetic altitudes or ZGSMs of starting point
        
            lats - a clist of geodetic latitudes or XGSMs of starting point
        
            lons - a list of longitude or YGSM of starting point

            Length of all three lists must be the same
        
            model - 0 for Tsyganenko, 1 for IGRF
        
            qualifier - 0 for conjugate, 1 for north_alt, 2 for south_alt, 3 for apex, 4 for GSM XY plane
        
            stopAlt - altitude in km to stop trace at, if qualifier is north_alt or south_alt.
                If other qualifier, this parameter is not required. Default is None, which will raise
                exception if qualifier is north_alt or south_alt

        Returns a tuple of tuples, one tuple for point in (alts, lats, lons) lists, where each tuple has
        three items:
    
            1. geodetic altitude or ZGSM of ending point
    
            2. geodetic latitude or XGSM of ending point
    
            3. longitude or YGSM of ending point
    
    
        If error, traceback includes error description
        &#34;&#34;&#34;
        scriptName = &#39;traceMagneticFieldService.py&#39;

        url = self.cgiurl + scriptName + &#39;?&#39;
        
        delimiter = &#39;,&#39;

        # append arguments
        url += &#39;year=%i&amp;&#39; % (int(year))
        url += &#39;month=%i&amp;&#39; % (int(month))
        url += &#39;day=%i&amp;&#39; % (int(day))
        url += &#39;hour=%i&amp;&#39; % (int(hour))
        url += &#39;min=%i&amp;&#39; % (int(minute))
        url += &#39;sec=%i&amp;&#39; % (int(second))
        url += &#39;inputType=%i&amp;&#39; % (int(inputType))
        url += &#39;outputType=%i&amp;&#39; % (int(outputType))
        in1Str = delimiter.join([str(item) for item in alts])
        url += &#39;in1=%s&amp;&#39; % (in1Str)
        in2Str = delimiter.join([str(item) for item in lats])
        url += &#39;in2=%s&amp;&#39; % (in2Str)
        in3Str = delimiter.join([str(item) for item in lons])
        url += &#39;in3=%s&amp;&#39; % (in3Str)
        url += &#39;model=%i&amp;&#39; % (int(model))
        url += &#39;qualifier=%i&amp;&#39; % (int(qualifier))
        if stopAlt == None:
            if int(qualifier) in (1,2):
                raise ValueError(&#39;stopAlt must be set for qualifer in (1,2)&#39;)
            else:
                stopAlt = 0.0
        url += &#39;stopAlt=%s&#39; % (str(stopAlt))
        
        # remove any pluses in the url due to scientific notation
        url = url.replace(&#39;+&#39;, &#39;%2B&#39;)

        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
        except:
            raise ValueError(&#39;unable to open url &#39; + str(url))

        page = mainUrl.read().decode(&#39;utf8&#39;)
        page = page.split(&#39;\n&#39;)

        mainUrl.close()

        # parse the result
        if len(page) == 0:
            raise ValueError(&#39;No data found at url&#39; + str(url))

        # check that html was not returned
        for line in page:
            if line.find(&#39;Error occurred&#39;) != -1:
                raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

        result = []
        
        for line in page:
            items = line.split(&#39;,&#39;)
            if len(items) &lt; 3:
                continue
            result.append((float(items[0]),
                           float(items[1]),
                           float(items[2])))

        return result
    
    
    def getVersion(self):
        &#34;&#34;&#34;getVersion gets the version number of Madrigal in form number dot number etc.
        
        Assumes version is 2.5 if no getVersionService.py installed
        &#34;&#34;&#34;
        scriptName = &#39;getVersionService.py&#39;

        url = self.cgiurl + scriptName

        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
        except:
            # if this fails, must be 2.5
            return(&#39;2.5&#39;)

        page = mainUrl.read().decode(&#39;utf-8&#39;)

        mainUrl.close()
        
        return(page.strip())
    
    
    def compareVersions(self, ver1, ver2):
        &#34;&#34;&#34;compareVersions returns False if ver1 &lt;= ver2, 0 True otherwise
        
        Inputs: version number strings, in form number dot number (any number of dots)
        &#34;&#34;&#34;
        return(distutils.version.LooseVersion(ver1) &gt; distutils.version.LooseVersion(ver2))
            

    def getCitedFilesFromUrl(self, url):
        &#34;&#34;&#34;getCitedFilesFromUrl returns a list of citations to individual Madrigal file from a group id url
        as found in a publication
        &#34;&#34;&#34;
        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
        except:
            raise ValueError(&#39;unable to open url &#39; + str(url))

        page = mainUrl.read().decode(&#39;utf8&#39;)
        page = page.strip().split(&#39;\n&#39;)

        mainUrl.close()
        
        return(page)
    
    
    def createCitationGroupFromList(self, citationList, user_fullname, user_email, user_affiliation):
        &#34;&#34;&#34;createCitationGroupFromList creates a new group citation given an input
        list of citations in the form: 
        &#39;https://w3id.org/cedar?experiment_list=experiments/2014/mlh/16mar13&amp;file_list=mlh130316g.007.hdf5&#39;
        or &#39;experiments/2014/mlh/16mar13&amp;file_list=mlh130316g.007.hdf5&#39;
        
        Inputs:
        
            citationList - list of citations
        
            user_fullname - full name of user making request

            user_email - email address of user making request

            user_affiliation - affiliation of user making request
            
        Returns:
        
            group citation (string)
        &#34;&#34;&#34;
        url = &#39;http://cedar.openmadrigal.org/createCitationGroupWithList?&#39;
        # temp only - until cedar updated
        #url = &#39;http://127.0.0.1:8000/createCitationGroupWithList?&#39;
        user_fullname = user_fullname.replace(&#39; &#39;,&#39;+&#39;).strip()
        url += &#39;user_fullname=%s&amp;&#39; % (user_fullname)
        user_email = user_email.strip()
        url += &#39;user_email=%s&amp;&#39; % (user_email)
        user_affiliation = user_affiliation.replace(&#39; &#39;,&#39;+&#39;).strip()
        url += &#39;user_affiliation=%s&amp;&#39; % (user_affiliation)
        for citation in citationList:
            if not citation == citationList[-1]:
                url += &#39;url=%s&amp;&#39; % (urlparse.quote_plus(citation))
            else:
                url += &#39;url=%s&#39; % (urlparse.quote_plus(citation))
        
        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
        except:
            raise ValueError(&#39;unable to open url &#39; + str(url))

        page = mainUrl.read().decode(&#39;utf8&#39;)
        page = page.strip()

        mainUrl.close()
        
        return(page)
    
    
    def getCitationListFromFilters(self, startDate, endDate, inst=None, kindat=None, 
                           seasonalStartDate=None, seasonalEndDate=None, 
                           includeNonDefault=False, expName=None, excludeExpName=None, 
                           fileDesc=None):
        &#34;&#34;&#34;getCitationListFromFilters returns a list of citations using filters similar to globalDownload.
        Result can then be used to create citation group using createCitationGroupFromList 
        
        Inputs:
                startDate: start datetime to filter experiments before in YYYY-MM-DD (required)
                endDate: end datetime to filter experiments after  in YYYY-MM-DD (required)
                inst: a list of instrument codes or names. If None, all instruments used. 
                    For names fnmatch will be used
                kindat: a list of kind of data codes or names. If None, all kindats used. 
                    For names fnmatch will be used
                seasonalStartDate: in form MM/DD, rejects all days earlier in year. If None,
                    implies 01/01
                seasonalEndDate: in form MM/DD, rejects all days later in year. If None,
                    implies 12/31
                includeNonDefault: if set, include realtime files when there are no default. If False,
                    implies only default files.
                expName: string - filter experiments by the experiment name.  fnmatch rules
                    If None, no filtering by experiment name.
                excludeExpName: string - exclude experiments by the experiment name.  fnmatch rules  
                    If None, no excluding experiments by experiment name.
                fileDesc: filter files using input file Description string via fnmatch. 
                    If None, no filtering by file name
        
        Returns a list with all citations in group, which can be used in createCitationGroupFromList
        &#34;&#34;&#34;
        url = &#39;http://cedar.openmadrigal.org/getCitationGroupWithFilters?&#39;
        # temp only - until cedar updated
        # url = &#39;http://127.0.0.1:8000/getCitationGroupWithFilters?&#39;
        url += &#39;startDate=%s&amp;&#39; % (startDate.strftime(&#39;%Y-%m-%d&#39;))
        url += &#39;endDate=%s&amp;&#39; % (endDate.strftime(&#39;%Y-%m-%d&#39;))
        if not inst is None:
            for thisInst in inst:
                url += &#39;inst=%s&amp;&#39; % (urlparse.quote_plus(str(thisInst)))
        if not kindat is None:
            for thisKindat in kindat:
                url += &#39;kindat=%s&amp;&#39; % (urlparse.quote_plus(str(thisKindat)))
        if not seasonalStartDate is None:
            url += &#39;seasonalStartDate=%s&amp;&#39; % (seasonalStartDate.strip())
        if not seasonalEndDate is None:
            url += &#39;seasonalEndDate=%s&amp;&#39; % (seasonalEndDate.strip())
        if includeNonDefault:
            url += &#39;includeNonDefault=True&amp;&#39;
        if not expName is None:
            url += &#39;expName=%s&amp;&#39; % (urlparse.quote_plus(expName.strip()))
        if not excludeExpName is None:
            url += &#39;excludeExpName=%s&amp;&#39; % (urlparse.quote_plus(excludeExpName.strip()))
        if not fileDesc is None:
            url += &#39;fileDesc=%s&amp;&#39; % (urlparse.quote_plus(fileDesc.strip()))
            
            
        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
        except:
            raise ValueError(&#39;unable to open url &#39; + str(url))

        page = mainUrl.read().decode(&#39;utf8&#39;)
        page = page.strip().split(&#39;\n&#39;)

        mainUrl.close()
        
        return(page)
    
    
        
    

class MadrigalInstrument:
    &#34;&#34;&#34;MadrigalInstrument is a class that encapsulates information about a Madrigal Instrument.


    Attributes::

      name (string) Example: &#39;Millstone Hill Incoherent Scatter Radar&#39;
      
      code (int) Example: 30
      
      mnemonic (3 char string) Example: &#39;mlh&#39;
      
      latitude (double) Example: 45.0
      
      longitude (double) Example: 110.0
      
      altitude (double)  Example: 0.015 (km)
      
      category (string) Example &#39;Incoherent Scatter Radars&#39;
            


    Non-standard Python modules used: None


    Change history:

    Written by &#34;Bill Rideout&#34;:mailto:wrideout@haystack.mit.edu  Feb. 10, 2004

    &#34;&#34;&#34;
    def __init__(self, name, code, mnemonic, latitude, longitude, altitude, category=&#39;unknown&#39;):
        &#34;&#34;&#34;__init__ initializes a MadrigalInstrument.

        Inputs::

            name - (string) Example: &#39;Millstone Hill Incoherent Scatter Radar&#39;
          
            code - (int, or string that can be converted) Example: 30
          
            mnemonic - (3 char string) Example: &#39;mlh&#39;
          
            latitude - (double, or string that can be converted) Example: 45.0
          
            longitude (double, or string that can be converted) Example: 110.0
          
            altitude (double, or string that can be converted)  Example: 0.015 (km)
            
            category  (string) Example: &#39;Incoherent Scatter Radars&#39;
        
        Returns: void

        Affects: Initializes all the class member variables.

        Exceptions: If illegal argument passed in.
        &#34;&#34;&#34;

        if not isStringType(name):
            raise ValueError(&#39;In MadrigalInstrument, name not string type: %s&#39; % (str(name)))

        self.name = name

        self.code = int(code)

        if not isStringType(mnemonic):
            raise ValueError(&#39;In MadrigalInstrument, mnemonic not string type: %s&#39; % (str(mnemonic)))

        if len(mnemonic) != 3:
            raise ValueError(&#39;In MadrigalInstrument, mnemonic not three characters: %s&#39; % (str(mnemonic)))

        self.mnemonic = mnemonic.lower()

        self.latitude = float(latitude)

        self.longitude = float(longitude)

        self.altitude = float(altitude)
        
        if not isStringType(category):
            raise ValueError(&#39;In MadrigalInstrument, category not string type: %s&#39; % (str(category)))
        
        self.category = category
        

    def __str__(self):
        &#34;&#34;&#34;return a readible form of this object&#34;&#34;&#34;
        retStr = &#39;&#39;
        retStr += &#39;name: %s\n&#39; % (self.name)
        retStr += &#39;code: %s\n&#39; % (str(self.code))
        retStr += &#39;mnemonic: %s\n&#39; % (self.mnemonic)
        retStr += &#39;latitude: %s\n&#39; % (str(self.latitude))
        retStr += &#39;longitude: %s\n&#39; % (str(self.longitude))
        retStr += &#39;altitude: %s\n&#39;%  (str(self.altitude))
        retStr += &#39;category: %s\n&#39;%  (self.category)
        return retStr



class MadrigalExperiment:
    &#34;&#34;&#34;MadrigalExperiment is a class that encapsulates information about a Madrigal Experiment.


    Attributes::

        id (int) Example: 10000111.  Uniquely identifies experiment.
        
        realUrl (string) the real url to display this experiment in a web browser.
        
        url (string) Example: &#39;http://madrigal.haystack.mit.edu/cgi-bin/madtoc/1997/mlh/03dec97&#39;
            Note: this is a an old url that no longer works, but it is the form stored in the metadata.
            See realUrl attribute for working url.
        
        name (string) Example: &#39;Wide Latitude Substorm Study&#39;
        
        siteid (int) Example: 1
        
        sitename (string) Example: &#39;Millstone Hill Observatory&#39;
        
        instcode (int) Code of instrument. Example: 30
        
        instname (string) Instrument name. Example: &#39;Millstone Hill Incoherent Scatter Radar&#39;
        
        startyear - int
           
        startmonth - int
       
        startday - int
       
        starthour - int
       
        startmin - int
       
        startsec - int
       
        endyear - int
       
        endmonth - int
       
        endday - int
       
        endhour - int
       
        endmin - int
       
        endsec - int

        isLocal - True if a local experiment, False if not

        madrigalUrl - url of Madrigal site.  Used if not a local experiment.
        
        pi - experiment Principal investigator
        
        piEmail - experiment Principal investigator&#39;s email
        
        realUrl - working url to experiment (use this instead of url)
            
        uttimestamp - st_mtime of expDir. None if not supported by the Madrigal site
        
        access - access code of the experiment (0 if public, 2 if public).  None if not
            supported by the Madrigal site.
            
        version - version of Madrigal site where data located in form I.I[.I] where I is an integer
            
    Non-standard Python modules used: None


    Change history:

    Written by &#34;Bill Rideout&#34;:mailto:wrideout@haystack.mit.edu  Feb. 10, 2004

    &#34;&#34;&#34;
    def __init__(self,
                 id,
                 url,
                 name,
                 siteid,
                 sitename,
                 instcode,
                 instname,
                 startyear,
                 startmonth,
                 startday,
                 starthour,
                 startmin,
                 startsec,
                 endyear,
                 endmonth,
                 endday,
                 endhour,
                 endmin,
                 endsec,
                 isLocal,
                 madrigalUrl,
                 pi,
                 piEmail,
                 uttimestamp,
                 access,
                 version):
        &#34;&#34;&#34;__init__ initializes a MadrigalExperiment.

        Inputs::

            id (int, or string that can be converted) Example: 10000111.  Uniquely identifies experiment.
        
            url (string) Example: &#39;http://madrigal.haystack.mit.edu/cgi-bin/madtoc/1997/mlh/03dec97&#39; - see 
                realUrl attribute for an actual url that works in the web
            
            name (string) Example: &#39;Wide Latitude Substorm Study&#39;
            
            siteid (int, or string that can be converted) Example: 1
            
            sitename (string) Example: &#39;Millstone Hill Observatory&#39;
            
            instcode (int, or string that can be converted) Code of instrument. Example: 30
            
            instname (string) Instrument name. Example: &#39;Millstone Hill Incoherent Scatter Radar&#39;

            startyear - int, or string that can be converted
           
            startmonth - int, or string that can be converted
       
            startday - int, or string that can be converted
       
            starthour - int, or string that can be converted
       
            startmin - int, or string that can be converted
       
            startsec - int, or string that can be converted
       
            endyear - int, or string that can be converted
       
            endmonth - int, or string that can be converted
       
            endday - int, or string that can be converted
       
            endhour - int, or string that can be converted
       
            endmin - int, or string that can be converted
       
            endsec - int, or string that can be converted
            
            isLocal - True if a local experiment, False if not

            madrigalUrl - url of Madrigal site.  Used if not a local experiment.
            
            pi - experiment PI
            
            piEmail - experiment PI email
            
            uttimestamp - st_mtime of expDir. None if not supported by the Madrigal site
        
            access - access code of the experiment (0 if public, 2 if public).  None if not
                supported by the Madrigal site.
                
            version - version of Madrigal site where data located in form I.I[.I] where I is an integer

        Returns: void

        Affects: Initializes all the class member variables.

        Exceptions: If illegal argument passed in.
        &#34;&#34;&#34;

        self.id = int(id)

        if not isStringType(url):
            raise ValueError(&#39;In MadrigalExperiment, url not string type: %s&#39; % (str(url)))

        self.url = url

        if not isStringType(name):
            raise ValueError(&#39;In MadrigalExperiment, name not string type: %s&#39; % (str(name)))

        self.name = name

        self.siteid = int(siteid)

        if not isStringType(sitename):
            raise ValueError(&#39;In MadrigalExperiment, sitename not string type: %s&#39; % (str(sitename)))

        self.sitename = sitename

        self.instcode = int(instcode)

        if not isStringType(instname):
            raise ValueError(&#39;In MadrigalExperiment, instname not string type: %s&#39; % (str(instname)))

        self.instname = instname

        self.startyear = int(startyear)

        self.startmonth = int(startmonth)

        self.startday = int(startday)

        self.starthour = int(starthour)

        self.startmin = int(startmin)

        self.startsec = int(startsec)

        self.endyear = int(endyear)

        self.endmonth = int(endmonth)

        self.endday = int(endday)

        self.endhour = int(endhour)

        self.endmin = int(endmin)

        self.endsec = int(endsec)

        if isLocal not in (True, False):
            raise ValueError(&#39;In MadrigalExperiment, isLocal not boolean: %s&#39; % (str(isLocal)))

        self.isLocal = isLocal

        if not isStringType(madrigalUrl):
            raise ValueError(&#39;In MadrigalExperiment, madrigalUrl not string type: %s&#39; % (str(madrigalUrl)))

        self.madrigalUrl = madrigalUrl
        
        if not isStringType(pi):
            raise ValueError(&#39;In MadrigalExperiment, pi not string type: %s&#39; % (str(pi)))

        self.pi = pi
        
        if not isStringType(piEmail):
            raise ValueError(&#39;In MadrigalExperiment, piEmail not string type: %s&#39; % (str(piEmail)))
                
        self.piEmail = piEmail
        
        if self.isLocal:
            self.realUrl = self._getRealExperimentUrl(version)
        else:
            self.realUrl = &#39;Cannot_get_real_url_for_remote_site&#39;
        
        self.uttimestamp = uttimestamp
        
        self.access = access     
        
        if not isStringType(version):
            raise ValueError(&#39;In MadrigalExperiment, version not string type: %s&#39; % (str(version)))
        self.version = version   
        

        
    def _getRealExperimentUrl(self, version):
        &#34;&#34;&#34;getRealExperimentUrl is a private method that returns the url used in a web browser to see 
        this experiment&#39;s page in full data access interface. Uses to create attribute realUrl.
        
        Inputs:
            version - version of Madrigal site where data located in form I.I[.I] where I is an integer
            
        real url depends on Madrigal version
        &#34;&#34;&#34;
        version_list = [int(item) for item in version.split(&#39;.&#39;)]
        retStr = &#39;&#39;
        index = self.url.find(&#39;/madtoc/&#39;)
        if version_list[0] == 2:
            retStr += self.url[:index] + &#39;/madExperiment.cgi?exp=&#39;
            retStr += self.url[index+8:] + &#39;&amp;displayLevel=0&amp;expTitle=&#39;
            try:
                retStr += urlparse.quote_plus(self.name) # python3
            except AttributeError:
                retStr += urllib.quote_plus(self.name.encode(&#39;utf8&#39;)) # python2
        else:
            retStr += self.url[:index] + &#39;/showExperiment/?experiment_list=%i&#39; % (self.id)
        return(retStr)
        

    def __str__(self):
        &#34;&#34;&#34;return a readible form of this object&#34;&#34;&#34;
        retStr = &#39;&#39;
        retStr += &#39;id: %s\n&#39; % (str(self.id))
        retStr += &#39;realUrl: %s\n&#39; % (self.realUrl)
        retStr += &#39;url: %s\n&#39; % (self.url)
        retStr += &#39;name: %s\n&#39; % (self.name)
        retStr += &#39;siteid: %s\n&#39; % (str(self.siteid))
        retStr += &#39;sitename: %s\n&#39; % (self.sitename)
        retStr += &#39;instcode: %s\n&#39;%  (str(self.instcode))
        retStr += &#39;instname: %s\n&#39; % (self.instname)
        retStr += &#39;startyear: %s\n&#39; % (str(self.startyear))
        retStr += &#39;startmonth: %s\n&#39;%  (str(self.startmonth))
        retStr += &#39;startday: %s\n&#39; % (str(self.startday))
        retStr += &#39;starthour: %s\n&#39;%  (str(self.starthour))
        retStr += &#39;startmin: %s\n&#39; % (str(self.startmin))
        retStr += &#39;startsec: %s\n&#39;%  (str(self.startsec))
        retStr += &#39;endyear: %s\n&#39; % (str(self.endyear))
        retStr += &#39;endmonth: %s\n&#39;%  (str(self.endmonth))
        retStr += &#39;endday: %s\n&#39; % (str(self.endday))
        retStr += &#39;endhour: %s\n&#39;%  (str(self.endhour))
        retStr += &#39;endmin: %s\n&#39; % (str(self.endmin))
        retStr += &#39;endsec: %s\n&#39;%  (str(self.endsec))
        retStr += &#39;isLocal: %s\n&#39; % (str(self.isLocal))
        retStr += &#39;madrigalUrl: %s\n&#39;%  (self.madrigalUrl)
        retStr += &#39;PI: %s\n&#39;%  (self.pi)
        retStr += &#39;PIEmail: %s\n&#39;%  (self.piEmail)
        retStr += &#39;uttimestamp: %s\n&#39;%  (str(self.uttimestamp))
        retStr += &#39;access: %s\n&#39;%  (str(self.access))
        retStr += &#39;Madrigal version: %s\n&#39;%  (self. version)
        return retStr

    def __cmp__(self, other):
        &#34;&#34;&#34; __cmp__ compares two MadrigalExperiment objects.

        Compared by start time, then by end time.
        &#34;&#34;&#34;
        dt1 = datetime.datetime(self.startyear, self.startmonth, self.startday,
                                self.starthour, self.startmin, self.startsec)
        dt2 = datetime.datetime(other.startyear, other.startmonth, other.startday,
                                other.starthour, other.startmin, other.startsec)
        result = cmp(dt1, dt2)
        if result != 0:
            return(result)

        
        dt1 = datetime.datetime(self.endyear, self.endmonth, self.endday,
                                self.endhour, self.endmin, self.endsec)
        dt2 = datetime.datetime(other.endyear, other.endmonth, other.endday,
                                other.endhour, other.endmin, other.endsec)
        return(cmp(dt1, dt2))     
    
    
    def __eq__(self, other):
        &#34;&#34;&#34; __eq__ compares two MadrigalExperiment objects for equality.

        Compared by start time and end time.
        &#34;&#34;&#34;
        dt1s = datetime.datetime(self.startyear, self.startmonth, self.startday,
                                self.starthour, self.startmin, self.startsec)
        dt2s = datetime.datetime(other.startyear, other.startmonth, other.startday,
                                other.starthour, other.startmin, other.startsec)

        
        dt1e = datetime.datetime(self.endyear, self.endmonth, self.endday,
                                self.endhour, self.endmin, self.endsec)
        dt2e = datetime.datetime(other.endyear, other.endmonth, other.endday,
                                other.endhour, other.endmin, other.endsec)
        return(dt1s == dt2s and dt1e == dt2e)                   
        
    def __ne__(self, other):
        &#34;&#34;&#34; __ne__ compares two MadrigalExperiment objects for inequality.

        Simply the inverse of __eq__
        &#34;&#34;&#34;
        return(not(self.__eq__(self, other)))
    
    
    def __lt__(self, other):
        &#34;&#34;&#34; __lt__ compares two MadrigalExperiment objects.

        Compared by start time only
        &#34;&#34;&#34;
        dt1 = datetime.datetime(self.startyear, self.startmonth, self.startday,
                                self.starthour, self.startmin, self.startsec)
        dt2 = datetime.datetime(other.startyear, other.startmonth, other.startday,
                                other.starthour, other.startmin, other.startsec)
        return (dt1 &lt; dt2)
    
    def __le__(self, other):
        &#34;&#34;&#34; __le__ compares two MadrigalExperiment objects.

        Compared by start time only
        &#34;&#34;&#34;
        dt1 = datetime.datetime(self.startyear, self.startmonth, self.startday,
                                self.starthour, self.startmin, self.startsec)
        dt2 = datetime.datetime(other.startyear, other.startmonth, other.startday,
                                other.starthour, other.startmin, other.startsec)
        return (dt1 &lt;= dt2)
    
    def __gt__(self, other):
        &#34;&#34;&#34; __gt__ compares two MadrigalExperiment objects.

        Compared by start time only
        &#34;&#34;&#34;
        dt1 = datetime.datetime(self.startyear, self.startmonth, self.startday,
                                self.starthour, self.startmin, self.startsec)
        dt2 = datetime.datetime(other.startyear, other.startmonth, other.startday,
                                other.starthour, other.startmin, other.startsec)
        return (dt1 &gt; dt2)
    
    def __ge__(self, other):
        &#34;&#34;&#34; __ge__ compares two MadrigalExperiment objects.

        Compared by start time only
        &#34;&#34;&#34;
        dt1 = datetime.datetime(self.startyear, self.startmonth, self.startday,
                                self.starthour, self.startmin, self.startsec)
        dt2 = datetime.datetime(other.startyear, other.startmonth, other.startday,
                                other.starthour, other.startmin, other.startsec)
        return (dt1 &gt;= dt2)
    
    
    
    


class MadrigalExperimentFile:
    &#34;&#34;&#34;MadrigalExperimentFile is a class that encapsulates information about a Madrigal ExperimentFile.


    Attributes::

        name (string) Example &#39;/opt/mdarigal/blah/mlh980120g.001&#39;
        
        kindat (int) Kindat code.  Example: 3001
        
        kindatdesc (string) Kindat description: Example &#39;Basic Derived Parameters&#39;
        
        category (int) (1=default, 2=variant, 3=history, 4=real-time)
        
        status (string)(&#39;preliminary&#39;, &#39;final&#39;, or any other description)
        
        permission (int)  0 for public, 1 for private

        expId - experiment id of the experiment this MadrigalExperimentFile belongs in
        
        doi - digital object identifier - citable url to file - or None if not found
            

    Non-standard Python modules used: None


    Change history:

    Written by &#34;Bill Rideout&#34;:mailto:wrideout@haystack.mit.edu  Feb. 10, 2004

    &#34;&#34;&#34;
    def __init__(self, name, kindat, kindatdesc, category, status, permission, expId = None, doi=None):
        &#34;&#34;&#34;__init__ initializes a MadrigalExperimentFile.

        Inputs::

            name - (string) Example &#39;/opt/mdarigal/blah/mlh980120g.001&#39;
        
            kindat - (int, or string that can be converted) Kindat code.  Example: 3001
        
            kindatdesc - (string) Kindat description: Example &#39;Basic Derived Parameters&#39;
        
            category - (int, or string that can be converted) (1=default, 2=variant, 3=history, 4=real-time)
        
            status - (string)(&#39;preliminary&#39;, &#39;final&#39;, or any other description)
        
            permission - (int, or string that can be converted)  0 for public, 1 for private

            expId - experiment id of the experiment this MadrigalExperimentFile belongs in
            
            doi - digital object identifier - citable url to file. Default is None

        
        Returns: void

        Affects: Initializes all the class member variables.

        Exceptions: If illegal argument passed in.
        &#34;&#34;&#34;

        if not isStringType(name):
            raise ValueError(&#39;In MadrigalExperimentFile, name not string type: %s&#39; % (str(name)))

        self.name = name

        self.kindat = int(kindat)

        if not isStringType(kindatdesc):
            raise ValueError(&#39;In MadrigalExperimentFile, kindatdesc not string type: %s&#39; % (str(kindatdesc)))

        self.kindatdesc = kindatdesc

        self.category = int(category)

        if not isStringType(status):
            raise ValueError(&#39;In MadrigalExperimentFile, status not string type: %s&#39; % (str(status)))

        self.status = status

        self.permission = int(permission)

        if expId == None:
            self.expId = None
        else:
            self.expId = int(expId)
            
        if not isStringType(doi) and not doi is None:
            raise ValueError(&#39;In MadrigalExperimentFile, doi not string type or None: %s&#39; % (str(doi)))
        self.doi = doi
            
        

    def __str__(self):
        &#34;&#34;&#34;return a readable form of this object&#34;&#34;&#34;
        retStr = &#39;&#39;
        retStr += &#39;name: %s\n&#39; % (self.name)
        retStr += &#39;kindat: %s\n&#39; % (str(self.kindat))
        retStr += &#39;kindatdesc: %s\n&#39; % (self.kindatdesc)
        retStr += &#39;category: %s\n&#39; % (str(self.category))
        retStr += &#39;status: %s\n&#39; % (self.status)
        retStr += &#39;permission: %s\n&#39;%  (str(self.permission))
        retStr += &#39;expId: %s\n&#39;%  (str(self.expId))
        retStr += &#39;doi: %s\n&#39;%  (self.doi)
        return retStr


class MadrigalParameter:
    &#34;&#34;&#34;MadrigalParameter is a class that encapsulates information about a Madrigal Parameter.


    Attributes::

        mnemonic (string) Example &#39;dti&#39;

        description (string) Example: &#34;F10.7 Multiday average observed (Ott)&#34;

        isError (int) 1 if error parameter, 0 if not

        units (string) Example &#34;W/m2/Hz&#34;

        isMeasured (int) 1 if measured, 0 if derivable

        category (string) Example: &#34;Time Related Parameter&#34;

        isSure (int) - 1 if parameter can be found for every record, 0 if can only be found for some

        isAddIncrement - 1 if additional increment, 0 if normal, -1 if unknown (this capability
                         only added with Madrigal 2.5)


    Non-standard Python modules used: None


    Change history:

    Written by &#34;Bill Rideout&#34;:mailto:wrideout@haystack.mit.edu  Aug. 8, 2005

    &#34;&#34;&#34;
    def __init__(self, mnemonic, description, isError, units, isMeasured, category, isSure, isAddIncrement):
        &#34;&#34;&#34;__init__ initializes a MadrigalParameter.

        Inputs::

            mnemonic (string) Example &#39;dti&#39;

            description (string) Example: &#34;F10.7 Multiday average observed (Ott)&#34;

            isError (int) 1 if error parameter, 0 if not

            units (string) Example &#34;W/m2/Hz&#34;

            isMeasured (int) 1 if measured, 0 if derivable

            category (string) Example: &#34;Time Related Parameter&#34;

            isSure (int) - 1 if parameter can be found for every record, 0 if can only be found for some

            isAddIncrement - 1 if additional increment, 0 if normal, -1 if unknown (this capability
                             only added with Madrigal 2.5)
 

        Returns: void

        Affects: Initializes all the class member variables.

        Exceptions: If illegal argument passed in.
        &#34;&#34;&#34;

        if not isStringType(mnemonic):
            raise ValueError(&#39;In MadrigalParameter, mnemonic not string type: %s&#39; % (str(mnemonic)))

        self.mnemonic = mnemonic

        if not isStringType(description):
            raise ValueError(&#39;In MadrigalParameter, description not string type: %s&#39; % (str(description)))

        self.description = description

        self.isError = int(isError)

        if not isStringType(units):
            raise ValueError(&#39;In MadrigalParameter, units not string type: %s&#39; % (str(units)))

        self.units = units

        self.isMeasured = int(isMeasured)

        if not isStringType(category):
            raise ValueError(&#39;In MadrigalParameter, category not string type: %s&#39; % (str(category)))

        self.category = category
            
        self.isSure = int(isSure)

        self.isAddIncrement = int(isAddIncrement)
        

    def __str__(self):
        &#34;&#34;&#34;return a readible form of this object&#34;&#34;&#34;
        retStr = &#39;&#39;
        retStr += &#39;mnemonic: %s\n&#39; % (self.mnemonic)
        retStr += &#39;description: %s\n&#39; % (self.description)
        retStr += &#39;isError: %s\n&#39; % (str(self.isError))
        retStr += &#39;units: %s\n&#39; % (self.units)
        retStr += &#39;isMeasured: %s\n&#39; % (str(self.isMeasured))
        retStr += &#39;category: %s\n&#39;%  (self.category)
        retStr += &#39;isSure: %s\n&#39;%  (str(self.isSure))
        retStr += &#39;isAddIncrement: %s\n&#39;%  (str(self.isAddIncrement))
        return retStr     



if __name__ == &#39;__main__&#39;:

    testInst  = MadrigalInstrument(&#34;Millstone Hill AMISR Radar&#34;, &#39;33&#39;, &#39;Mlh&#39;, 45.0, 110.0, &#39;0.015&#39;)
    print(testInst)

    
    testExp  = MadrigalExperiment(&#39;10000111&#39;,
                                  &#39;http://madrigal.haystack.mit.edu/cgi-bin/madtoc/1997/mlh/03dec97&#39;,
                                  &#34;World day&#34;,
                                  &#39;33&#39;,
                                  &#39;Westford&#39;,
                                  30,
                                  &#39;SuperDarn&#39;,
                                  1993,1,2,3,4,5,
                                  &#39;1993&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,
                                  True,
                                  &#39;http://madrigal.haystack.mit.edu&#39;)
    print(testExp)


    testExpFile  = MadrigalExperimentFile(&#34;/opt/madrigal/blah/mlh980120g.001&#34;, &#39;33&#39;, &#39;Blah blah&#39;, &#39;2&#39;, &#39;final&#39;, &#39;0&#39;)
    print(testExpFile)

    testData = MadrigalData(&#39;http://grail/madrigal/&#39;)

    # save a file
    testData.downloadFile(&#39;/home/grail/brideout/madroot/experiments/1998/mlh/20jan98/mil980120g.001&#39;,
                          &#39;/tmp/junk.001&#39;)

    instList = testData.getAllInstruments()

    for inst in instList:
        print(inst)

    expList = testData.getExperiments(20, 1960,1,1,0,0,0,2005,1,1,0,0,0)

    for exp in expList:
        print(exp)

    fileList = testData.getExperimentFiles(expList[0].id)

    for file in fileList:
        print(file)

    print((&#39;Parameter list for %s&#39; % (file.name)))
    parmList = testData.getExperimentFileParameters(file.name)
    for parm in parmList:
        print((str(parm) + &#39;\n&#39;))

    testData.simplePrint(&#39;/home/grail/brideout/madroot/experiments/1998/mlh/20jan98/mlh980120g.001&#39;,
                               &#39;Bill Rideout&#39;, &#39;brideout@haystack.mit.edu&#39;, &#39;MIT Haystack&#39;)

    print((testData.isprint(&#39;/home/grail/brideout/madroot/experiments/1998/mlh/20jan98/mlh980120g.001&#39;,
                           &#39;gdalt,ti&#39;, &#39;filter=gdalt,500,600 filter=ti,1000,2000&#39;,&#39;Bill Rideout&#39;,
                           &#39;brideout@haystack.mit.edu&#39;, &#39;MIT Haystack&#39;)))

    result = testData.madCalculator(1999,2,15,12,30,0,45,55,5,-170,-150,10,200,200,0,&#39;bmag,bn&#39;)

    for line in result:
        print(line)

    result = testData.madTimeCalculator(1999,2,15,12,30,0,
                                        1999,2,20,12,30,0,
                                        24.0, &#39;kp,dst&#39;)

    for line in result:
        print(line)

    print(&#39;test of radarToGeodetic with arg 42,-70,0.1,(0,90),(45,45),(1000,1000):&#39;)
    result = testData.radarToGeodetic(42,-70,0.1,(0,90),(45,45),(1000,1000))
    print(result)

    print(&#39;test of radarToGeodetic with arg 42,-70,0.1,90, 45, 1000:&#39;)
    result = testData.radarToGeodetic(42,-70,0.1,90,45,1000)
    print(result)

    print(&#39;test of geodeticToRadar with arg 42,-70,0.1,(50,60),(-70,-70),(1000,1000):&#39;)
    result = testData.geodeticToRadar(42,-70,0.1,(50,60),(-70,-70),(1000,1000))
    print(result)

    print(&#39;test of geodeticToRadar with arg 42,-70,0.1,50, -70, 1000:&#39;)
    result = testData.geodeticToRadar(42,-70,0.1,50,-70,1000)
    print(result)

    
    print(&#39;test of traceMagneticField with args 1999,2,15,12,30,0,0,0,[300], [42], [-71],1,1,200&#39;)
    result = testData.traceMagneticField(1999,2,15,12,30,0,0,0,[300], [42], [-71],1,1,200)
    print(result)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="madrigalWeb.madrigalWeb.isStringType"><code class="name flex">
<span>def <span class="ident">isStringType</span></span>(<span>input)</span>
</code></dt>
<dd>
<div class="desc"><p>isStringType is a method designed to work with both python 2 and 3 to test for string type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isStringType(input):
    &#34;&#34;&#34;isStringType is a method designed to work with both python 2 and 3 to test for string type
    &#34;&#34;&#34;
    if type(input) == str:
        return(True)
    try:
        if type(input) == unicode:
            return(True)
    except:
        return(False)
    return(False)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="madrigalWeb.madrigalWeb.MadrigalData"><code class="flex name class">
<span>class <span class="ident">MadrigalData</span></span>
<span>(</span><span>url)</span>
</code></dt>
<dd>
<div class="desc"><p>MadrigalData is a class that acquires data from a particular Madrigal site.</p>
<p>Usage example::</p>
<pre><code>import madrigalWeb.madrigalWeb

test =  madrigalWeb.madrigalWeb.MadrigalData('http://madrigal.haystack.mit.edu')

instList = test.getInstrumentList()
</code></pre>
<p>Non-standard Python modules used: None</p>
<p>Change history:</p>
<p>Written by "Bill Rideout":mailto:wrideout@haystack.mit.edu
Feb. 10, 2004</p>
<p><strong>init</strong> initializes a MadrigalData object.</p>
<p>Inputs::</p>
<pre><code>url - (string) url of main page of madrigal site. Example: 'http://madrigal.haystack.mit.edu'
</code></pre>
<p>Affects: Converts main page to cgi url, and stores that.</p>
<p>Also stores self.siteDict, with key = site id, value= site url, and self.siteId</p>
<p>Exceptions: If url not found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MadrigalData:
    &#34;&#34;&#34;MadrigalData is a class that acquires data from a particular Madrigal site.


    Usage example::

        import madrigalWeb.madrigalWeb
    
        test =  madrigalWeb.madrigalWeb.MadrigalData(&#39;http://madrigal.haystack.mit.edu&#39;)

        instList = test.getInstrumentList()
            


    Non-standard Python modules used: None


    Change history:

    Written by &#34;Bill Rideout&#34;:mailto:wrideout@haystack.mit.edu  Feb. 10, 2004

    &#34;&#34;&#34;
    def __init__(self, url):
        &#34;&#34;&#34;__init__ initializes a MadrigalData object.

        Inputs::

            url - (string) url of main page of madrigal site. Example: &#39;http://madrigal.haystack.mit.edu&#39;

        Affects: Converts main page to cgi url, and stores that.

        Also stores self.siteDict, with key = site id, value= site url, and self.siteId

        Exceptions: If url not found.
        &#34;&#34;&#34;
        cgiName = &#39;accessData.cgi&#39;

        regExp = re.compile(&#39;&#34;.*&#39; + cgiName)

        # get base of url
        urlParts = urlparse.urlparse(url)

        urlBase = urlParts[0] + &#39;://&#39; + urlParts[1]

        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
        except:
            raise ValueError(&#39;unable to open url &#39; + str(url))

        page = mainUrl.read().decode(&#39;utf-8&#39;)
        
        mainUrl.close()

        result = regExp.search(page)
        
        # check for success
        if result == None:
            raise ValueError(&#39;invalid url: &#39; + str(url))

        result = result.group()
        
        if type(result) in (list, tuple):
            result = result[0]
            
        self.cgiurl = urlBase + result[1:(-1*len(cgiName))]

        try:
            self.siteDict = self.__getSiteDict()
        except:
            self.cgiurl = url
            if not self.cgiurl[-1] == &#39;/&#39;:
                self.cgiurl += &#39;/&#39;
            self.siteDict = self.__getSiteDict()
            

        self.siteId = self.__getSiteId()
        
        # get Madrigal version
        self._madVers = self.getVersion()


    def __getSiteDict(self):
        &#34;&#34;&#34;__getSiteDict returns a dictionary with key = site id, value= site url.

        Uses getMetadata cgi script
        &#34;&#34;&#34;
        url = urlparse.urljoin(self.cgiurl, &#39;getMetadata?fileType=5&#39;)
        
        f = urllib2.urlopen(url, timeout=TIMEOUT2)

        page = f.read().decode(&#39;utf-8&#39;)

        f.close()

        lines = page.split(&#39;\n&#39;)

        siteDict = {}

        for line in lines:
            items = line.split(&#39;,&#39;)
            if len(items) &lt; 4:
                continue
            site = int(items[0])
            thisUrl = &#39;http://%s/%s&#39; % (items[2], items[3])
            siteDict[site] = thisUrl

        return siteDict


    def __getSiteId(self):
        &#34;&#34;&#34;__getSiteId returns the local site id

        Uses getMetadata cgi script
        &#34;&#34;&#34;
        url = urlparse.urljoin(self.cgiurl, &#39;getMetadata?fileType=0&#39;)

        f = urllib2.urlopen(url, timeout=TIMEOUT2)

        page = f.read().decode(&#39;utf-8&#39;)

        f.close()

        lines = page.split(&#39;\n&#39;)

        for line in lines:
            items = line.split(&#39;,&#39;)
            if len(items) &lt; 4:
                continue
            siteId = int(items[3])
            return(siteId)

        raise IOError(&#39;No siteId found&#39;)
            
        



    def getAllInstruments(self):
        &#34;&#34;&#34; returns a list of all MadrigalInstruments at the given Madrigal site&#34;&#34;&#34;

        scriptName = &#39;getInstrumentsService.py&#39;

        url = self.cgiurl + scriptName

        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
        except:
            raise ValueError(&#39;unable to open url &#39; + str(url))

        page = mainUrl.read().decode(&#39;utf8&#39;)
        page = page.split(&#39;\n&#39;)

        mainUrl.close()

        # parse the result
        if len(page) == 0:
            raise ValueError(&#39;No data found at url&#39; + str(url))

        # check that html was not returned
        for line in page:
            if line.find(&#39;Error occurred&#39;) != -1:
                raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

        result = []

        for line in page:
            items = line.split(&#39;,&#39;)
            if len(items) &lt; 5:
                continue
            if len(items) &gt; 6:
                category = items[6]
            else:
                category = &#39;unknown&#39;
            result.append(MadrigalInstrument(items[0],
                                             items[1],
                                             items[2],
                                             items[3],
                                             items[4],
                                             items[5],
                                             category))

        return result


    
    def getExperiments(self,
                       code,
                       startyear,
                       startmonth,
                       startday,
                       starthour,
                       startmin,
                       startsec,
                       endyear,
                       endmonth,
                       endday,
                       endhour,
                       endmin,
                       endsec,
                       local=1):
        &#34;&#34;&#34; returns a list of all MadrigalExperiments that meet criteria at the given Madrigal site

        Inputs:

           code - int or list of ints representing instrument code(s). Special value of 0 selects all instruments.
           
           startyear - int or string convertable to int
           
           startmonth - int or string convertable to int
           
           startday - int or string convertable to int
           
           starthour - int or string convertable to int
           
           startmin - int or string convertable to int
           
           startsec - int or string convertable to int
           
           endyear - int or string convertable to int
           
           endmonth - int or string convertable to int
           
           endday - int or string convertable to int
           
           endhour - int or string convertable to int
           
           endmin - int or string convertable to int
           
           endsec - int or string convertable to int

           local - 0 if all sites desired, 1 (default) if only local experiments desired

        Outputs:

            List of MadrigalExperiment objects that meet the criteria.  Note that if the returned
            MadrigalExperiment is not local, the experiment id will be -1.  This means that you
            will need to create a new MadrigalData object with the url of the 
            non-local experiment (MadrigalExperiment.madrigalUrl), and then call 
            getExperiments a second time using that Madrigal url.  This is because 
            while Madrigal sites share metadata about experiments, the real experiment ids are only
            known by the individual Madrigal sites.  See examples/exampleMadrigalWebServices.py
            for an example of this.


        &#34;&#34;&#34;

        scriptName = &#39;getExperimentsService.py&#39;

        url = self.cgiurl + scriptName + &#39;?&#39;

        # first append code(s)
        if type(code) == list:
            for item in code:
                url += &#39;code=%i&amp;&#39; % (int(item))
        else:
            url += &#39;code=%i&amp;&#39; % (int(code))

        # append times
        url += &#39;startyear=%i&amp;&#39; % (int(startyear))
        url += &#39;startmonth=%i&amp;&#39; % (int(startmonth))
        url += &#39;startday=%i&amp;&#39; % (int(startday))
        url += &#39;starthour=%i&amp;&#39; % (int(starthour))
        url += &#39;startmin=%i&amp;&#39; % (int(startmin))
        url += &#39;startsec=%i&amp;&#39; % (int(startsec))
        url += &#39;endyear=%i&amp;&#39; % (int(endyear))
        url += &#39;endmonth=%i&amp;&#39; % (int(endmonth))
        url += &#39;endday=%i&amp;&#39; % (int(endday))
        url += &#39;endhour=%i&amp;&#39; % (int(endhour))
        url += &#39;endmin=%i&amp;&#39; % (int(endmin))
        url += &#39;endsec=%i&amp;&#39; % (int(endsec))
        url += &#39;local=%i&#39;% (int(local))
        


        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
        except:
            raise ValueError(&#39;unable to open url &#39; + str(url))
                

        

        page = mainUrl.read().decode(&#39;utf8&#39;, errors=&#39;replace&#39;)
        page = page.split(&#39;\n&#39;)

        mainUrl.close()

        # parse the result
        if len(page) == 0:
            return []

        # check that error was not returned
        for line in page:
            if line.find(&#39;Error occurred&#39;) != -1:
                raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

        result = []


        for line in page:
            items = line.split(&#39;,&#39;)
            # calculate isLocal
            if len(items) &lt; 20:
                continue
            if int(items[3]) == self.siteId:
                isLocal = True
            else:
                isLocal = False
            if isLocal:
                expIdStr = items[0]
            else:
                expIdStr = &#39;-1&#39;
            if len(items) &gt; 21:
                pi = items[20]
                piEmail = items[21]
            else:
                pi = &#39;unknown&#39;
                piEmail = &#39;unknown&#39;
            if len(items) &gt; 23:
                uttimestamp = int(items[22])
                access = int(items[23])
            else:
                uttimestamp = None
                access = None
                
            result.append(MadrigalExperiment(expIdStr,
                                             items[1],
                                             items[2],
                                             items[3],
                                             items[4],
                                             items[5],
                                             items[6],
                                             items[7],
                                             items[8],
                                             items[9],
                                             items[10],
                                             items[11],
                                             items[12],
                                             items[13],
                                             items[14],
                                             items[15],
                                             items[16],
                                             items[17],
                                             items[18],
                                             isLocal,
                                             self.siteDict[int(items[3])],
                                             pi,
                                             piEmail,
                                             uttimestamp,
                                             access,
                                             self._madVers))
            

        return result


    def getExperimentFiles(self, id, getNonDefault=False):
        &#34;&#34;&#34; returns a list of all default MadrigalExperimentFiles for a given experiment id

        Inputs:

           id - Experiment id.

           getNonDefault - if False (the default), only get default files, or realtime
                           files if no default files found.  If True, get all files.
                           In general, users should set this to False because default files
                           are the most reliable.

        Outputs:

            List of MadrigalExperimentFile objects for that experiment id


        &#34;&#34;&#34;

        scriptName = &#39;getExperimentFilesService.py&#39;
        
        if int(id) == -1:
            err_str = &#34;&#34;&#34;Illegal experiment id -1.  This is usually caused by calling
            getExperiments with the isLocal flag set to 0.  To get the experiment id for a non-local
            experiment, you will need to create a new MadrigalData object with the url of the 
            non-local experiment (MadrigalExperiment.madrigalUrl), and then call 
            getExperiments a second time using that Madrigal url.  This is because 
            while Madrigal sites share metadata about experiments, the real experiment ids are only
            known by the individual Madrigal sites. See examples/exampleMadrigalWebServices.py
            for an example of this.
            &#34;&#34;&#34;
            raise ValueError(err_str)

        url = self.cgiurl + scriptName + &#39;?id=%i&#39; % (int(id))


        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
        except:
            raise ValueError(&#39;unable to open url &#39; + str(url))
                

        page = mainUrl.read().decode(&#39;utf8&#39;)
        page = page.split(&#39;\n&#39;)

        mainUrl.close()

        # parse the result
        if len(page) == 0:
            return []

        # check that error was not returned
        for line in page:
            if line.find(&#39;Error occurred&#39;) != -1:
                raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

        result = []

        # find out if no default files.  If so, return realtime also
        hasDefault = False
        for line in page:
            items = line.split(&#39;,&#39;)
            if len(items) &lt; 4:
                continue
            if int(items[3]) == 1:
                hasDefault = True
                break

        for line in page:
            items = line.split(&#39;,&#39;)
            if len(items) &lt; 4:
                continue
            category = int(items[3])
            if hasDefault and category != 1 and not getNonDefault:
                continue
            if not hasDefault and category != 4 and not getNonDefault:
                continue
            if len(items) &gt; 6:
                doi = items[6]
            else:
                doi = None
            result.append(MadrigalExperimentFile(items[0],
                                                 items[1],
                                                 items[2],
                                                 items[3],
                                                 items[4],
                                                 items[5],
                                                 id,
                                                 doi))
            

        return result


    def getExperimentFileParameters(self,fullFilename):
        &#34;&#34;&#34; getExperimentFileParameters returns a list of all measured and derivable parameters in file

        Inputs:

           fullFilename - full path to experiment file as returned by getExperimentFiles.

        Outputs:

            List of MadrigalParameter objects for that fullFilename.  Includes both measured
            and derivable parameters in file.


        &#34;&#34;&#34;

        scriptName = &#39;getParametersService.py&#39;

        url = self.cgiurl + scriptName + &#39;?filename=%s&#39; % (str(fullFilename))


        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
        except:
            raise ValueError(&#39;unable to open url &#39; + str(url))
                

        page = mainUrl.read().decode(&#39;utf8&#39;)
        page = page.split(&#39;\n&#39;)

        mainUrl.close()

        # parse the result
        if len(page) == 0:
            return []

        # check that error was not returned
        for line in page:
            if line.find(&#39;Error occurred&#39;) != -1:
                raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

        result = []



        for line in page:
            items = line.split(&#39;\\&#39;)
            # with Madrigal 2.5, isAddIncrement was added as 8th column
            if len(items) &lt; 7:
                continue
            try:
                isAddIncrement = int(items[7])
            except:
                isAddIncrement = -1
            result.append(MadrigalParameter(items[0],
                                            items[1],
                                            int(items[2]),
                                            items[3],
                                            int(items[4]),
                                            items[5],
                                            int(items[6]),
                                            isAddIncrement))
            

        return result


    def simplePrint(self, filename, user_fullname, user_email, user_affiliation):
        &#34;&#34;&#34;simplePrint prints the data in the given file is a simple ascii format.

        simplePrint prints only the parameters in the file, without filters or derived
        parameters.  To choose which parameters to print, to print derived parameters, or
        to filter the data, use isprint instead.

        Inputs:

            filename - The absolute filename to be printed.  Returned by getExperimentFiles.

            user_fullname - full name of user making request

            user_email - email address of user making request

            user_affiliation - affiliation of user making request

        Returns: string representing all data in the file in ascii, space-delimited form.
                 The first line if the list of parameters printed.  The first six parameters will
                 always be year, month, day, hour, min, sec, representing the middle time of
                 the measurment.
        &#34;&#34;&#34;
        parms = self.getExperimentFileParameters(filename)

        parmStr = &#39;year,month,day,hour,min,sec&#39;
        labelStr = &#39;YEAR     MONTH       DAY      HOUR       MIN       SEC        &#39;

        for parm in parms:
            if parm.isMeasured and parm.isAddIncrement != 1:
                parmStr += &#39;,%s&#39; % (parm.mnemonic)
                thisLabel = parm.mnemonic[:11].upper()
                labelStr += &#39;%s%s&#39; % (thisLabel, &#39; &#39;*(11-len(thisLabel)))

        retStr = &#39;%s\n&#39; % (labelStr)

        retStr += self.isprint(filename, parmStr, &#39;&#39;, user_fullname, user_email, user_affiliation)

        return(retStr)

        

    def isprint(self, filename, parms, filters, user_fullname, user_email, user_affiliation, outputFile=None):
        &#34;&#34;&#34;returns as a string the isprint output given filename, parms, filters without headers or summary.

        Inputs:

            filename - The absolute filename to be analyzed by isprint.

            parms - Comma delimited string listing requested parameters (no spaces allowed).

            filters - Space delimited string listing filters desired, as in isprint command

            user_fullname - full name of user making request

            user_email - email address of user making request

            user_affiliation - affiliation of user making request
            
            outputFile - if not None, download the results to outputFile.  If outputFile has an extension
                of .h5, .hdf, or .hdf5, will download in Madrigal Hdf5 format.  If it has a .nc extension, will
                download as netCDF4. Otherwise, it will download as column delimited ascii.
                Trying to save as Hdf5 or netCDF4 with a Madrigal 2 site will raise an exception

        Returns:
        
            a string holding the isprint output
        &#34;&#34;&#34;
        
        scriptName = &#39;isprintService.py&#39;

        # build the complete cgi string, replacing characters as required by cgi standard

        url = self.cgiurl + scriptName + &#39;?&#39;

        
        url += &#39;file=%s&amp;&#39; % (filename.replace(&#39;/&#39;, &#39;%2F&#39;))
        if parms.find(&#39; &#39;) != -1:
            parms = parms.replace(&#39; &#39;, &#39;&#39;) # remove all spaces
        parms = parms.replace(&#39;+&#39;,&#39;%2B&#39;)
        parms = parms.replace(&#39;,&#39;,&#39;+&#39;)
        url += &#39;parms=%s&amp;&#39; % (parms)
        filters = filters.replace(&#39;=&#39;,&#39;%3D&#39;)
        filters = filters.replace(&#39;,&#39;,&#39;%2C&#39;)
        filters = filters.replace(&#39;/&#39;,&#39;%2F&#39;)
        filters = filters.replace(&#39;+&#39;,&#39;%2B&#39;)
        filters = filters.replace(&#39; &#39;,&#39;+&#39;)
        url += &#39;filters=%s&amp;&#39; % (filters)
        user_fullname = user_fullname.replace(&#39; &#39;,&#39;+&#39;).strip()
        url += &#39;user_fullname=%s&amp;&#39; % (user_fullname)
        user_email = user_email.strip()
        url += &#39;user_email=%s&amp;&#39; % (user_email)
        user_affiliation = user_affiliation.replace(&#39; &#39;,&#39;+&#39;).strip()
        url += &#39;user_affiliation=%s&#39; % (user_affiliation)
        if not outputFile is None:
            url += &#39;&amp;output=%s&#39; % (os.path.basename(outputFile))
            filename, file_extension = os.path.splitext(outputFile)
            if file_extension in (&#39;.hdf5&#39;, &#39;.h5&#39;, &#39;.hdf&#39;):
                format = &#39;Hdf5&#39;
            elif file_extension in (&#39;.nc&#39;,):
                format = &#39;netCDF4&#39;
            else:
                format = &#39;ascii&#39;
            # if Hdf5 or netCDF4, make sure site is 3 or greater
            if format in (&#39;Hdf5&#39;, &#39;netCDF4&#39;):
                version = self.getVersion()
                if distutils.version.LooseVersion(version) &lt; distutils.version.LooseVersion(&#39;3.0&#39;):
                    raise ValueError(&#39;Madrigal site at %s is below 3.0, cannot convert to Hdf5 or netCDF4&#39; % (self.cgiurl))
        else:
            format = &#39;ascii&#39;

        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT)
        except:
            raise ValueError(&#39;unable to open url &#39; + str(url))
                
        if format == &#39;ascii&#39;:
            page = mainUrl.read().decode(&#39;utf-8&#39;)
        else:
            page = mainUrl.read()

        mainUrl.close()

        if format == &#39;ascii&#39;:
            if page.find(&#39;Error occurred&#39;) != -1:
                raise ValueError(&#39;error raised using url &#39; + str(url))
    
        if outputFile is None:
            return page
        
        else:
            if format == &#39;ascii&#39;:
                f = open(outputFile, &#39;w&#39;)
            else:
                f = open(outputFile, &#39;wb&#39;)
            f.write(page)
            f.close()


    def madCalculator(self,
                      year,
                      month,
                      day,
                      hour,
                      min,
                      sec,
                      startLat,
                      endLat,
                      stepLat,
                      startLong,
                      endLong,
                      stepLong,
                      startAlt,
                      endAlt,
                      stepAlt,
                      parms,
                      oneDParmList=[],
                      oneDParmValues=[]):
        &#34;&#34;&#34;

        Input arguments:

            1. year - int 

            2. month - int 

            3. day - int
            
            4. hour - int 

            5. min - int 

            6. sec - int 

            7. startLat - Starting geodetic latitude, -90 to 90 (float)

            8. endLat - Ending geodetic latitude, -90 to 90 (float)

            9. stepLat - Latitude step (0.1 to 90) (float)

            10. startLong - Starting geodetic longitude, -180 to 180  (float)

            11. endLong - Ending geodetic longitude, -180 to 180 (float)

            12. stepLong - Longitude step (0.1 to 180) (float)

            13. startAlt - Starting geodetic altitude, &gt;= 0 (float)

            14. endAlt - Ending geodetic altitude, &gt; 0 (float)

            15. stepAlt - Altitude step (&gt;= 0.1) (float)

            16. parms - comma delimited string of Madrigal parameters desired

            17. oneDParmList - a list of one-D parameters whose values should
                               be set for the calculation.  Can be codes or mnemonics.
                               Defaults to empty list.

            18. oneDParmValues - a list of values (doubles) associated with the one-D
                                 parameters specified in oneDParmList. Defaults to empty list.

        Returns:

            A list of lists of doubles, where each list contains 3 + number of parameters doubles.
            The first three doubles are the input latitude, longitude, and altitude.  The rest of the
            doubles are the values of each of the calculated values.  If the value cannot be calculated,
            it will be set to nan.

            Example:

                result = testData.madCalculator(1999,2,15,12,30,0,45,55,5,-170,-150,10,200,200,0,&#39;bmag,bn&#39;)

                result = [  [45.0, -170.0, 200.0, 4.1315700000000002e-05, 2.1013500000000001e-05]
                            [45.0, -160.0, 200.0, 4.2336899999999998e-05, 2.03685e-05]
                            [45.0, -150.0, 200.0, 4.3856400000000002e-05, 1.97411e-05]
                            [50.0, -170.0, 200.0, 4.3913599999999999e-05, 1.9639999999999998e-05]
                            [50.0, -160.0, 200.0, 4.4890099999999999e-05, 1.8870999999999999e-05]
                            [50.0, -150.0, 200.0, 4.6337800000000002e-05, 1.80077e-05]
                            [55.0, -170.0, 200.0, 4.6397899999999998e-05, 1.78115e-05]
                            [55.0, -160.0, 200.0, 4.7265400000000003e-05, 1.6932500000000001e-05]
                            [55.0, -150.0, 200.0, 4.85495e-05,            1.5865399999999999e-05] ]

                Columns:     gdlat  glon    gdalt  bmag                    bn

        &#34;&#34;&#34;

        scriptName = &#39;madCalculatorService.py&#39;

        url = self.cgiurl + scriptName + &#39;?year&#39;

        if len(oneDParmList) != len(oneDParmValues):
            raise ValueError(&#39;len(oneDParmList) != len(oneDParmValues)&#39;)
        
        if parms.find(&#39; &#39;) != -1:
            parms = parms.replace(&#39; &#39;, &#39;&#39;) # remove all spaces

        # append arguments
        url += &#39;=%i&amp;month&#39; % (int(year))
        url += &#39;=%i&amp;day&#39; % (int(month))
        url += &#39;=%i&amp;hour&#39; % (int(day))
        url += &#39;=%i&amp;min&#39; % (int(hour))
        url += &#39;=%i&amp;sec&#39; % (int(min))
        url += &#39;=%i&amp;startLat&#39; % (int(sec))
        url += &#39;=%f&amp;endLat&#39; % (float(startLat))
        url += &#39;=%f&amp;stepLat&#39; % (float(endLat))
        url += &#39;=%f&amp;startLong&#39; % (float(stepLat))
        url += &#39;=%f&amp;endLong&#39; % (float(startLong))
        url += &#39;=%f&amp;stepLong&#39; % (float(endLong))
        url += &#39;=%f&amp;startAlt&#39; % (float(stepLong))
        url += &#39;=%f&amp;endAlt&#39; % (float(startAlt))
        url += &#39;=%f&amp;stepAlt&#39; % (float(endAlt))
        url += &#39;=%f&amp;parms&#39; % (float(stepAlt))
        url += &#39;=%s&#39; % (parms)

        for i in range(len(oneDParmList)):
            url += &#39;&amp;oneD=%s,%s&#39; % (str(oneDParmList[i]), str(oneDParmValues[i]))
            
        # remove any pluses in the url due to scientific notation
        url = url.replace(&#39;+&#39;, &#39;%2B&#39;)

        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT)
        except:
            raise ValueError(&#39;unable to open url &#39; + str(url))
                

        page = mainUrl.read().decode(&#39;utf8&#39;)
        page = page.split(&#39;\n&#39;)

        mainUrl.close()

        # parse the result
        if len(page) == 0:
            raise ValueError(&#39;No data found at url&#39; + str(url))

        # check that error was not returned
        for line in page:
            if line.find(&#39;Error occurred&#39;) != -1:
                raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

        result = []

        # parse output
        for line in page:
            items = line.split()
            if len(items) &lt; 3:
                # blank line
                continue
            newList = []
            for item in items:
                try:
                    newList.append(float(item))
                except:
                    newList.append(str(item))
            result.append(newList)

        return result
    
    
    def madCalculator2(self,
                      year,
                      month,
                      day,
                      hour,
                      min,
                      sec,
                      latList,
                      lonList,
                      altList,
                      parms,
                      oneDParmList=[],
                      oneDParmValues=[],
                      twoDParmList = [],
                      twoDParmValues = []):
        &#34;&#34;&#34;
        madCalculator2 is similar to madCalculator, except that a random collection of points in space can be specified,
        rather than a grid of points.  Also, a user can input 2D data.
        
        Added to Madrigal2.6 as web service - will not run on earlier Madrigal installations.

        Input arguments:

            1. year - int 

            2. month - int 

            3. day - int
            
            4. hour - int 

            5. min - int 

            6. sec - int 

            7. latList - a list of geodetic latitudes, -90 to 90

            8. lonList - a list of longitudes, -180 to 180. Length must = lats
            
            9. altList - a list of geodetic altitudes in km. Length must = lats

            10. parms - comma delimited string of Madrigal parameters desired

            11. oneDParmList - a list of one-D parameters whose values should
                               be set for the calculation.  Can be codes or mnemonics.
                               Defaults to empty list.

            12. oneDParmValues - a list of values (doubles) associated with the one-D
                                 parameters specified in oneDParmList. Defaults to empty list.
                                 
            13. twoDParmList - a python list of two-D parameters as mnemonics.  Defaults to [].
            
            14. twoDParmValues - a python list of lists of len = len(twoDParmList). Each individual 
                             list is a list of doubles representing values of the two-D
                             parameter set in twoDParmList, with a length = number 
                             of points (or equal to len(lats)). Defaults to [].

        Returns:

            A list of lists of doubles, where each list contains 3 + number of parameters doubles.
            The first three doubles are the input latitude, longitude, and altitude.  The rest of the
            doubles are the values of each of the calculated values.  If the value cannot be calculated,
            it will be set to nan.

            Example:

                result = testData.madCalculator2(1999,2,15,12,30,0,[45,55],[-170,-150],[200,300],&#39;sdwht,kp&#39;)

                result = [ [1999.0, 2.0, 15.0, 12.0, 30.0, 0.0, 3.0, 15.0]
                           [1999.0, 2.0, 15.0, 12.0, 45.0, 0.0, 3.0, 15.0]
                           [1999.0, 2.0, 15.0, 13.0, 0.0, 0.0, 3.0, 15.0]
                           [1999.0, 2.0, 15.0, 13.0, 15.0, 0.0, 3.0, 15.0] ]


                Columns:     gdlat  glon    gdalt  sdwht   kp
                
        Now uses POST to avoid long url issue

    &#34;&#34;&#34;
    
        # verify Madrigal site can call this command
        if self.compareVersions(&#39;2.6&#39;, self._madVers):
            raise IOError(&#39;madCalculator2 requires Madrigal 2.6 or greater, but this site is version %s&#39; % (self._madVers))

        scriptName = &#39;madCalculator2Service.py&#39;
        
        if parms.find(&#39; &#39;) != -1:
            parms = parms.replace(&#39; &#39;, &#39;&#39;) # remove all spaces

        url = self.cgiurl + scriptName
        

        # error checking
        if len(oneDParmList) != len(oneDParmValues):
            raise ValueError(&#39;len(oneDParmList) != len(oneDParmValues)&#39;)
        
        if len(latList) == 0:
            raise ValueError(&#39;length of latList must be at least one&#39;)
        
        if len(latList) != len(lonList) or len(latList) != len(altList):
            raise ValueError(&#39;lengths of latList, lonList, altList must all be equal&#39;)
        
        if len(oneDParmList) != len(oneDParmValues):
            raise ValueError(&#39;len(oneDParmList) != len(oneDParmValues)&#39;)
        
        postUrl = &#39;year&#39;
        # append arguments
        delimiter = &#39;,&#39;
        postUrl += &#39;=%i&amp;month&#39; % (int(year))
        postUrl += &#39;=%i&amp;day&#39; % (int(month))
        postUrl += &#39;=%i&amp;hour&#39; % (int(day))
        postUrl += &#39;=%i&amp;min&#39; % (int(hour))
        postUrl += &#39;=%i&amp;sec&#39; % (int(min))
        postUrl += &#39;=%i&amp;lats=&#39; % (int(sec))
        for i in range(len(latList)):
            postUrl += str(latList[i])
            if i + 1 &lt; len(latList):
                postUrl += &#39;,&#39;
        postUrl += &#39;&amp;longs=&#39;
        for i in range(len(lonList)):
            postUrl += str(lonList[i])
            if i + 1 &lt; len(lonList):
                postUrl += &#39;,&#39;
        postUrl += &#39;&amp;alts=&#39;
        for i in range(len(altList)):
            postUrl += str(altList[i])
            if i + 1 &lt; len(altList):
                postUrl += &#39;,&#39;
        postUrl += &#39;&amp;parms=%s&#39; % (parms)

        for i in range(len(oneDParmList)):
            postUrl += &#39;&amp;oneD=%s,%s&#39; % (str(oneDParmList[i]), str(oneDParmValues[i]))
            
        for i in range(len(twoDParmList)):
            postUrl += &#39;&amp;twoD=%s,&#39; % (str(twoDParmList[i]))
            for j in range(len(twoDParmValues[i])):
                postUrl += str(twoDParmValues[i][j])
                if j + 1 &lt; len(twoDParmValues[i]):
                    postUrl += &#39;,&#39;
                    
        # remove any pluses in the url due to scientific notation
        postUrl = postUrl.replace(&#39;+&#39;, &#39;%2B&#39;)
            
        data = postUrl.encode(&#34;utf-8&#34;)

        # read main url
        try:
            req = urllib2.Request(url)
            response = urllib2.urlopen(req, data=data, timeout=TIMEOUT)
        except:
            raise ValueError(&#39;unable to open url &#39; + str((url, postUrl)))
                

        page = response.read().decode(&#39;utf8&#39;)
        page = page.split(&#39;\n&#39;)

        response.close()

        # parse the result
        if len(page) == 0:
            raise ValueError(&#39;No data found at url&#39; + str(url))

        # check that error was not returned
        for line in page:
            if line.find(&#39;Error occurred&#39;) != -1:
                raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

        result = []

        # parse output
        for line in page:
            items = line.split()
            if len(items) &lt; 3:
                # blank line
                continue
            newList = []
            for item in items:
                try:
                    newList.append(float(item))
                except:
                    newList.append(str(item))
            result.append(newList)

        return result
    
    
    def madCalculator3(self,
                      yearList,
                      monthList,
                      dayList,
                      hourList,
                      minList,
                      secList,
                      latList,
                      lonList,
                      altList,
                      parms,
                      oneDParmList=[],
                      oneDParmValues=[],
                      twoDParmList = [],
                      twoDParmValues = []):
        &#34;&#34;&#34;
        madCalculator3 is similar to madCalculator, except that multiple times can be specified,
        where each time can have its own unique spatial positions and 1D and 2D parms. It is
        equivalent to multiple calls to madCalculator2, except that it should greatly improve 
        performance where multiple calls to madCalculator2 are required for different times.
        The only restriction is that the same parameters must be requested for every time.
        
        Added to Madrigal2.6 as web service - will not run on earlier Madrigal installations.
        
        Now uses POST to send arguments, due to large volume of data possible

        Input arguments:

            1. yearList - a list of years, one for each time requested (ints)

            2. monthList - a list of months, one for each time requested. (ints)

            3. dayList - a list of days, one for each time requested. (ints)
            
            4. hourList - a list of hours, one for each time requested. (ints)

            5. minList - a list of minutes, one for each time requested. (ints)

            6. secList - a list of seconds, one for each time requested. (ints)

            7. latList - a list of lists of geodetic latitudes, -90 to 90.  The
               first list is for the first time, the second for the second time, etc.
               The list do not need to have the same number of points.  The number
               of times must match yearList.
               Data organization: latList[timeIndex][positionIndex]

            8. lonList - a list of lists of longitudes, -180 to 180. The
               first list is for the first time, the second for the second time, etc.
               The list do not need to have the same number of points.  The number
               of times must match yearList. Lens must match latList
               Data organization: lonList[timeIndex][positionIndex]
            
            9. altList - a list of lists of geodetic altitudes in km. The
               first list is for the first time, the second for the second time, etc.
               The list do not need to have the same number of points.  The number
               of times must match yearList. Lens must match latList
               Data organization: altList[timeIndex][positionIndex]

            10. parms - comma delimited string of Madrigal parameters desired

            11. oneDParmList - a list of one-D parameters whose values should
                               be set for the calculation.  Can be codes or mnemonics.
                               Defaults to empty list.

            12. oneDParmValues - a list of lists of values (doubles) associated with the one-D
                                 parameters specified in oneDParmList. Defaults to empty list.
                                 The first list is for the first 1D parameter in oneDParmList,
                                 and must be on length len(yearList).  The second list is for 
                                 the second parameter, etc. 
                                 Data organization: onDParmValues[parameterIndex][timeIndex]
                                 
            13. twoDParmList - a python list of of two-D parameters as mnemonics.  Defaults to [].
            
            14. twoDParmValues - a list of lists of lists of values (doubles) associated with the two-D
                                 parameters specified in twoDParmList. Defaults to empty list.
                                 The first list is for the first 2D parameter in oneDParmList,
                                 and must be a list of length len(yearList).  Each list in that
                                 list must be of len(num positions for that time). The second list is for 
                                 the second parameter, etc. 
                                 Data organization: twoDParmValues[parameterIndex][timeIndex][positionIndex]

        Returns:

            A list of lists of doubles, where each list contains 9 + number of parameters doubles.
            The first nine doubles are:
            1) year, 2) month, 3) day, 4) hour, 5) minute, 6) second,
            7) input latitude, 8) longitude, and 9) altitude.  
            The rest of the doubles are the values of each of the calculated values.  If the value 
            cannot be calculated, it will be set to nan.

            Example:

                testData.madCalculator3(yearList=[2001,2001], monthList=[3,3], dayList=[19,20],
                                     hourList=[12,12], minList=[30,40], secList=[20,0],
                                     latList=[[45,46,47,48.5],[46,47,48.2,49,50]],
                                     lonList=[[-70,-71,-72,-73],[-70,-71,-72,-73,-74]],
                                     altList=[[145,200,250,300.5],[200,250,300,350,400]],
                                     parms=&#39;bmag,pdcon,ne_model&#39;,
                                     oneDParmList=[&#39;kinst&#39;,&#39;elm&#39;],
                                     oneDParmValues=[[31.0,31.0],[45.0,50.0]],
                                     twoDParmList=[&#39;ti&#39;,&#39;te&#39;,&#39;ne&#39;],
                                     twoDParmValues=[[[1000,1000,1000,1000],[1000,1000,1000,1000,1000]],
                                                     [[1100,1200,1300,1400],[1500,1000,1100,1200,1300]],
                                                     [[1.0e10,1.0e10,1.0e10,1.0e10],[1.0e10,1.0e10,1.0e10,1.0e10,1.0e10]]])


                Columns:     year month day hour minute second gdlat  glon  gdalt  bmag  pdcon  ne_model

    &#34;&#34;&#34;
        # verify Madrigal site can call this command
        if self.compareVersions(&#39;2.6&#39;, self._madVers):
            raise IOError(&#39;madCalculator3 requires Madrigal 2.6 or greater, but this site is version %s&#39; % (self._madVers))


        scriptName = &#39;madCalculator3Service.py&#39;

        url = self.cgiurl + scriptName
        
        postUrl = &#39;&#39;

        # error checking
        try:
            totalTimes = len(yearList)
        except:
            raise ValueError(&#39;yearList must be a list, not %s&#39; % (str(yearList)))
        
        if len(monthList) != totalTimes or \
           len(dayList) != totalTimes or \
           len(hourList) != totalTimes or \
           len(minList) != totalTimes or \
           len(secList) != totalTimes:
            raise ValueError(&#39;Not all time lists have same length&#39;)
        
        if parms.find(&#39; &#39;) != -1:
            parms = parms.replace(&#39; &#39;, &#39;&#39;) # remove all spaces
        
        # add time arguments
        postUrl += &#39;year=&#39;
        for i, year in enumerate(yearList):
            postUrl += &#39;%i&#39; % (year)
            if i+1 &lt; len(yearList):
                postUrl += &#39;,&#39;
                
        postUrl += &#39;&amp;month=&#39;
        for i, month in enumerate(monthList):
            postUrl += &#39;%i&#39; % (month)
            if i+1 &lt; len(monthList):
                postUrl += &#39;,&#39;
        
        postUrl += &#39;&amp;day=&#39;
        for i, day in enumerate(dayList):
            postUrl += &#39;%i&#39; % (day)
            if i+1 &lt; len(dayList):
                postUrl += &#39;,&#39;
        
        postUrl += &#39;&amp;hour=&#39;
        for i, hour in enumerate(hourList):
            postUrl += &#39;%i&#39; % (hour)
            if i+1 &lt; len(hourList):
                postUrl += &#39;,&#39;
                
        postUrl += &#39;&amp;min=&#39;
        for i, minute in enumerate(minList):
            postUrl += &#39;%i&#39; % (minute)
            if i+1 &lt; len(minList):
                postUrl += &#39;,&#39;
                
        postUrl += &#39;&amp;sec=&#39;
        for i, sec in enumerate(secList):
            postUrl += &#39;%i&#39; % (sec)
            if i+1 &lt; len(secList):
                postUrl += &#39;,&#39;
                
        # get numPos list from latList
        numPos = []
        for lats in latList:
            numPos.append(len(lats))
            
        postUrl += &#39;&amp;numPos=&#39;
        for i, pos in enumerate(numPos):
            postUrl += &#39;%i&#39; % (pos)
            if i+1 &lt; len(numPos):
                postUrl += &#39;,&#39;
                
        postUrl += &#39;&amp;lats=&#39;
        for i, posList in enumerate(latList):
            if len(posList) != numPos[i]:
                raise ValueError(&#39;mismatched number of points in latList&#39;)
            for j, pos in enumerate(posList):
                postUrl += &#39;%f&#39; % (pos)
                if i+1 &lt; len(latList) or j+1 &lt; len(posList):
                    postUrl += &#39;,&#39;
                    
        postUrl += &#39;&amp;longs=&#39;
        for i, posList in enumerate(lonList):
            if len(posList) != numPos[i]:
                raise ValueError(&#39;mismatched number of points in lonList&#39;)
            for j, pos in enumerate(posList):
                postUrl += &#39;%f&#39; % (pos)
                if i+1 &lt; len(lonList) or j+1 &lt; len(posList):
                    postUrl += &#39;,&#39;
                    
        postUrl += &#39;&amp;alts=&#39;
        for i, posList in enumerate(altList):
            if len(posList) != numPos[i]:
                raise ValueError(&#39;mismatched number of points in altList&#39;)
            for j, pos in enumerate(posList):
                postUrl += &#39;%f&#39; % (pos)
                if i+1 &lt; len(altList) or j+1 &lt; len(posList):
                    postUrl += &#39;,&#39;
                    
        postUrl += &#39;&amp;parms=%s&#39; % (parms)
                                                                  
        if len(oneDParmList) != len(oneDParmValues):
            raise ValueError(&#39;len(oneDParmList) != len(oneDParmValues)&#39;)

        for i, parm in enumerate(oneDParmList):
            postUrl += &#39;&amp;oneD=%s,&#39; % (str(parm))
            if len(oneDParmValues[i]) != totalTimes:
                raise ValueError(&#39;wrong number of 1D parms for %s&#39; % (str(parm)))
            for j, value in enumerate(oneDParmValues[i]):
                postUrl += &#39;%f&#39; % (value)
                if j+1 &lt; len(oneDParmValues[i]):
                    postUrl += &#39;,&#39;
                    
        for i, parm in enumerate(twoDParmList):
            postUrl += &#39;&amp;twoD=%s,&#39; % (str(parm))
            if len(twoDParmValues[i]) != totalTimes:
                raise ValueError(&#39;wrong number of 2D parms for %s&#39; % (str(parm)))
            for j, valueList in enumerate(twoDParmValues[i]):
                if len(valueList) != numPos[j]:
                    raise ValueError(&#39;wrong number of 2D parms for %s&#39; % (str(parm)))
                for k, value in enumerate(valueList):
                    postUrl += &#39;%f&#39; % (value)
                    if j+1 &lt; len(twoDParmValues[i]) or k+1 &lt; len(valueList):
                        postUrl += &#39;,&#39;  
                        
        # remove any pluses in the url due to scientific notation
        postUrl = postUrl.replace(&#39;+&#39;, &#39;%2B&#39;)
                 
        data = postUrl.encode(&#39;utf8&#39;)

        # read main url
        try:
            req = urllib2.Request(url)
            response = urllib2.urlopen(req, data=data, timeout=TIMEOUT)
        except:
            raise ValueError(&#39;unable to open url &#39; + str((url, postUrl)))
                

        page = response.read().decode(&#39;utf8&#39;)
        page = page.split(&#39;\n&#39;)

        response.close()

        # parse the result
        if len(page) == 0:
            raise ValueError(&#39;No data found at url&#39; + str(url))

        # check that error was not returned
        for line in page:
            if line.find(&#39;Error occurred&#39;) != -1:
                raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

        result = []
        
        # time data to add to each line
        year=None
        month=None
        day=None
        hour=None
        minute=None
        second=None
        
        for line in page:
            items = line.split()
            if len(items) &lt; 3:
                # blank line
                continue
            if line.find(&#39;TIME&#39;) != -1:
                # new time found
                dates=items[1].split(&#39;/&#39;)
                year = int(dates[2])
                month = int(dates[0])
                day = int(dates[1])
                times=items[2].split(&#39;:&#39;)
                hour = int(times[0])
                minute = int(times[1])
                second = int(times[2])
                continue
            newList = [year,month,day,hour,minute,second]
            for item in items:
                try:
                    newList.append(float(item))
                except:
                    newList.append(str(item))
            result.append(newList)

        return result


    def madTimeCalculator(self,
                          startyear,
                          startmonth,
                          startday,
                          starthour,
                          startmin,
                          startsec,
                          endyear,
                          endmonth,
                          endday,
                          endhour,
                          endmin,
                          endsec,
                          stephours,
                          parms):
        &#34;&#34;&#34;

        Input arguments:

            1. startyear - int 

            2. startmonth - int 

            3. startday - int
            
            4. starthour - int 

            5. startmin - int 

            6. startsec - int

            7. endyear - int 

            8. endmonth - int 

            9. endday - int
            
            10. endhour - int 

            11. endmin - int 

            12. endsec - int

            13. stephours - float - number of hours per time step

            14. parms - comma delimited string of Madrigal parameters desired (must not depend on location)

        Returns:

            A list of lists, where each list contains 6 ints (year, month, day, hour, min, sec)  + number
            of parameters.  If the value cannot be calculated, it will be set to nan.

            Example:

                result = testData.madTestCalculator(1999,2,15,12,30,0,
                                                    1999,2,20,12,30,0,
                                                    24.0, &#39;kp,dst&#39;)

                result = [[1999.0, 2.0, 15.0, 12.0, 30.0, 0.0, 3.0, -9.0]
                          [1999.0, 2.0, 16.0, 12.0, 30.0, 0.0, 1.0, -6.0]
                          [1999.0, 2.0, 17.0, 12.0, 30.0, 0.0, 4.0, -31.0]
                          [1999.0, 2.0, 18.0, 12.0, 30.0, 0.0, 6.7000000000000002, -93.0]
                          [1999.0, 2.0, 19.0, 12.0, 30.0, 0.0, 5.2999999999999998, -75.0]]

                Columns:     year, month, day, hour, min, sec, kp, dst

        &#34;&#34;&#34;

        scriptName = &#39;madTimeCalculatorService.py&#39;

        url = self.cgiurl + scriptName + &#39;?startyear&#39;
        
        if parms.find(&#39; &#39;) != -1:
            parms = parms.replace(&#39; &#39;, &#39;&#39;) # remove all spaces

        # append arguments
        url += &#39;=%i&amp;startmonth&#39; % (int(startyear))
        url += &#39;=%i&amp;startday&#39; % (int(startmonth))
        url += &#39;=%i&amp;starthour&#39; % (int(startday))
        url += &#39;=%i&amp;startmin&#39; % (int(starthour))
        url += &#39;=%i&amp;startsec&#39; % (int(startmin))
        url += &#39;=%i&amp;endyear&#39; % (int(startsec))
        url += &#39;=%i&amp;endmonth&#39; % (int(endyear))
        url += &#39;=%i&amp;endday&#39; % (int(endmonth))
        url += &#39;=%i&amp;endhour&#39; % (int(endday))
        url += &#39;=%i&amp;endmin&#39; % (int(endhour))
        url += &#39;=%i&amp;endsec&#39; % (int(endmin))
        url += &#39;=%i&amp;stephours&#39; % (int(endsec))
        url += &#39;=%f&amp;parms&#39; % (float(stephours))
        url += &#39;=%s&#39; % (parms)
        
        # remove any pluses in the url due to scientific notation
        url = url.replace(&#39;+&#39;, &#39;%2B&#39;)

        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT)
        except:
            raise ValueError(&#39;unable to open url &#39; + str(url))
                

        page = mainUrl.read().decode(&#39;utf8&#39;)
        page = page.split(&#39;\n&#39;)

        mainUrl.close()

        # parse the result
        if len(page) == 0:
            raise ValueError(&#39;No data found at url&#39; + str(url))

        # check that error was not returned
        for line in page:
            if line.find(&#39;Error occurred&#39;) != -1:
                raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

        result = []

        # parse output
        for line in page:
            items = line.split()
            if len(items) &lt; 3:
                # blank line
                continue
            newList = []
            for item in items:
                try:
                    newList.append(float(item))
                except:
                    newList.append(str(item))
            result.append(newList)

        return result



    def radarToGeodetic(self,
                        slatgd,
                        slon,
                        saltgd,
                        az,
                        el,
                        radarRange):
        &#34;&#34;&#34;radarToGeodetic converts arrays of az, el, and ranges to geodetic locations.

        Input arguments:

            1. slatgd - radar geodetic latitude 

            2. slon - radar longitude 

            3. saltgd - radar altitude
            
            4. az - either a single azimuth, or a list of azimuths 

            5. el - either a single elevation, or a list of elevations.  If so, len(el)
                    must = len(az)

            6. radarRange - either a single range, or a list of ranges.  If so, len(radarRange)
                            must = len(az)


        Returns:

            A list of lists, where each list contains 3 floats (gdlat, glon, and gdalt)
        &#34;&#34;&#34;
        scriptName = &#39;radarToGeodeticService.py&#39;

        url = self.cgiurl + scriptName + &#39;?slatgd&#39;

        # append arguments
        url += &#39;=%f&amp;slon&#39; % (float(slatgd))
        url += &#39;=%f&amp;saltgd&#39; % (float(slon))
        url += &#39;=%f&amp;&#39; % (float(saltgd))

        if type(az) == list or type(az) == tuple:
            if len(az) != len(el) or len(az) != len(radarRange):
                raise ValueError(&#39;all lists most have same length&#39;)
            for i in range(len(az)):
                if i == 0:
                    arg = str(az[i])
                else:
                    arg += &#39;,&#39; + str(az[i])
            url += &#39;az=%s&amp;&#39; % (arg)

            for i in range(len(el)):
                if i == 0:
                    arg = str(el[i])
                else:
                    arg += &#39;,&#39; + str(el[i])
            url += &#39;el=%s&amp;&#39; % (arg)

            for i in range(len(radarRange)):
                if i == 0:
                    arg = str(radarRange[i])
                else:
                    arg += &#39;,&#39; + str(radarRange[i])
            url += &#39;range=%s&#39; % (arg)

        else:
            url += &#39;az=%f&amp;&#39; % (az)
            url += &#39;el=%f&amp;&#39; % (el)
            url += &#39;range=%f&amp;&#39; % (radarRange)
            
        # remove any pluses in the url due to scientific notation
        url = url.replace(&#39;+&#39;, &#39;%2B&#39;)

        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
        except:
            raise ValueError(&#39;unable to open url &#39; + str(url))
                
        page = mainUrl.read().decode(&#39;utf8&#39;)
        page = page.split(&#39;\n&#39;)

        mainUrl.close()

        # parse the result
        if len(page) == 0:
            raise ValueError(&#39;No data found at url&#39; + str(url))

        # check that error was not returned
        for line in page:
            if line.find(&#39;Error occurred&#39;) != -1:
                raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

        result = []

        # parse output
        for line in page:
            items = line.split(&#39;,&#39;)
            if len(items) &lt; 3:
                # blank line
                continue
            newList = []
            for item in items:
                try:
                    newList.append(float(item))
                except:
                    newList.append(str(item))
            result.append(newList)

        return result


    def geodeticToRadar(self,
                        slatgd,
                        slon,
                        saltgd,
                        gdlat,
                        glon,
                        gdalt):
        &#34;&#34;&#34;geodeticToRadar converts arrays of points in space to az, el, and range.

        Input arguments:

            1. slatgd - radar geodetic latitude 

            2. slon - radar longitude 

            3. saltgd - radar altitude
            
            4. gdlat - either a single geodetic latitude, or a list of geodetic latitudes 

            5. glon - either a single longitude, or a list of longitudes.  If so, len(gdlat)
                      must = len(glon)

            6. gdalt - either a single deodetic altitude, or a list of geodetic altitudes.
                       If so, len(gdalt) must = len(gdlat)


        Returns:

            A list of lists, where each list contains 3 floats (az, el, and range)
        &#34;&#34;&#34;
        scriptName = &#39;geodeticToRadarService.py&#39;

        url = self.cgiurl + scriptName + &#39;?slatgd&#39;

        # append arguments
        url += &#39;=%f&amp;slon&#39; % (float(slatgd))
        url += &#39;=%f&amp;saltgd&#39; % (float(slon))
        url += &#39;=%f&amp;&#39; % (float(saltgd))

        if type(gdlat) == list or type(gdlat) == tuple:
            if len(gdlat) != len(glon) or len(gdlat) != len(gdalt):
                raise ValueError(&#39;all lists most have same length&#39;)
            for i in range(len(gdlat)):
                if i == 0:
                    arg = str(gdlat[i])
                else:
                    arg += &#39;,&#39; + str(gdlat[i])
            url += &#39;gdlat=%s&amp;&#39; % (arg)

            for i in range(len(glon)):
                if i == 0:
                    arg = str(glon[i])
                else:
                    arg += &#39;,&#39; + str(glon[i])
            url += &#39;glon=%s&amp;&#39; % (arg)

            for i in range(len(gdalt)):
                if i == 0:
                    arg = str(gdalt[i])
                else:
                    arg += &#39;,&#39; + str(gdalt[i])
            url += &#39;gdalt=%s&#39; % (arg)

        else:
            url += &#39;gdlat=%f&amp;&#39; % (gdlat)
            url += &#39;glon=%f&amp;&#39; % (glon)
            url += &#39;gdalt=%f&amp;&#39; % (gdalt)
            
        # remove any pluses in the url due to scientific notation
        url = url.replace(&#39;+&#39;, &#39;%2B&#39;)

        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
        except:
            raise ValueError(&#39;unable to open url &#39; + str(url))
                
        page = mainUrl.read().decode(&#39;utf8&#39;)
        page = page.split(&#39;\n&#39;)

        mainUrl.close()

        # parse the result
        if len(page) == 0:
            raise ValueError(&#39;No data found at url&#39; + str(url))

        # check that error was not returned
        for line in page:
            if line.find(&#39;Error occurred&#39;) != -1:
                raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

        result = []

        # parse output
        for line in page:
            items = line.split(&#39;,&#39;)
            if len(items) &lt; 3:
                # blank line
                continue
            newList = []
            for item in items:
                try:
                    newList.append(float(item))
                except:
                    newList.append(str(item))
            result.append(newList)

        return result


    def downloadFile(self, filename, destination, user_fullname, user_email, user_affiliation, 
                     format=&#39;simple&#39;):
        &#34;&#34;&#34;downloadFile will download a Cedar file in the specified format.

        Inputs:

            filename - The absolute filename to as returned via getExperimentFiles.

            destination - where the file is to be stored
            
            user_fullname - full name of user making request

            user_email - email address of user making request

            user_affiliation - affiliation of user making request

            format - file format desired.  May be  &#39;simple&#39;, &#39;hdf5&#39;, &#39;netCDF4&#39;,
                &#39;madrigal&#39;, &#39;blockedBinary&#39;, &#39;ncar&#39;,
                 &#39;unblockedBinary&#39;, or &#39;ascii&#39;.  Default is &#39;simple&#39;
                 Simple is a simple ascii space delimited column format.
                 Simple and hdf5 are recommended since they are standard formats
                     
                hdf5 format works for Madrigal 2.6 or later
                netCDF4 format works for Madrigal 3.0 or later
                madrigal&#39;, &#39;blockedBinary&#39;, &#39;ncar&#39;,
                 &#39;unblockedBinary&#39;, or &#39;ascii&#39; no longer supported for Madrigal 3.

        &#34;&#34;&#34;
        fileType = 0
        if format not in (&#39;hdf5&#39;, &#39;madrigal&#39;, &#39;blockedBinary&#39;, &#39;ncar&#39;, 
                          &#39;unblockedBinary&#39;, &#39;ascii&#39;, &#39;simple&#39;, &#39;netCDF4&#39;):
            raise ValueError(&#39;Illegal format specified: %s&#39; % (str(format)))
        if format == &#39;blockedBinary&#39;:
            fileType = 1
        elif format == &#39;ncar&#39;:
            fileType = 2
        elif format == &#39;unblockedBinary&#39;:
            fileType = 3
        elif format == &#39;simple&#39;:
            fileType = -1
        elif format == &#39;hdf5&#39;:
            # verify Madrigal site can handle this argument
            if self.compareVersions(&#39;2.6&#39;, self._madVers):
                raise IOError(&#39;downloadFile with hdf5 format requires Madrigal 2.6 or greater, but this site is version %s&#39; % (self._madVers))
            fileType = -2
        elif format == &#39;netCDF4&#39;:
            # verify Madrigal site can handle this argument
            if self.compareVersions(&#39;3.0&#39;, self._madVers):
                raise IOError(&#39;downloadFile with netCDF4 format requires Madrigal 3.0 or greater, but this site is version %s&#39; % (self._madVers))
            fileType = -3
        else:
            fileType = 4
            
        # verify no old formats specified if Madrigal 3
        if fileType &gt; 0:
            if not self.compareVersions(&#39;3.0&#39;, self._madVers):
                raise IOError(&#39;Only Madrigal 2.X sites can create old style files, but this site is version %s&#39; % (self._madVers))

        
        url = urlparse.urljoin(self.cgiurl,&#39;getMadfile.cgi?fileName=%s&amp;fileType=%i&amp;&#39; % (filename, fileType))
        user_fullname = user_fullname.replace(&#39; &#39;,&#39;+&#39;).strip()
        url += &#39;user_fullname=%s&amp;&#39; % (user_fullname)
        user_email = user_email.strip()
        url += &#39;user_email=%s&amp;&#39; % (user_email)
        user_affiliation = user_affiliation.replace(&#39; &#39;,&#39;+&#39;).strip()
        url += &#39;user_affiliation=%s&#39; % (user_affiliation)
        
        CHUNK = 16 * 1024

        urlFile = urllib2.urlopen(url, timeout=TIMEOUT)
        
        if format in (&#39;ascii&#39;, &#39;simple&#39;):
            f = open(destination, &#39;w&#39;)
        else:
            f = open(destination, &#39;wb&#39;)

        while(True):
            if format in (&#39;ascii&#39;, &#39;simple&#39;):
                try:
                    data = urlFile.read(CHUNK).decode(&#39;utf8&#39;)
                except:
                    # probably gzip ascii - convert
                    f.close()
                    try:
                        os.remove(destination)
                    except:
                        pass
                    urlFile.close()
                    urlFile = urllib2.urlopen(url, timeout=TIMEOUT)
                    f = open(destination + &#39;.gz&#39;, &#39;wb&#39;)
                    format = &#39;gzip&#39;
                    data = urlFile.read(CHUNK)
                    
            else:
                data = urlFile.read(CHUNK)
            if not data:
                break
            f.write(data)
            
        urlFile.close()
        
        f.close()
        
        
    
    def listFileTimes(self, expDir=None):
        &#34;&#34;&#34;listFileTimes lists the filenames and last modification times for all files in a Madrigal database.

        Inputs: expDir - experiment directory to which to start.  May be any directory or subdirectory below 
            experiments[0-9]*.  Path may be absolute or relative to experiments[0-9]*.  If None (the default),
            include entire experiments[0-9]* directory(s).  Examples: (&#39;/opt/madrigal/experiments/1998&#39;,
            &#39;experiments/2002/gps&#39;)
            
        Returns: a list of tuple of 1. filename relative to experiments[0-9]* directory, and 2) datetime in UT of 
            last file modification
            
        Requires:  Madrigal 2.6 or greater
        &#34;&#34;&#34;
        # verify Madrigal site can call this command
        if self.compareVersions(&#39;2.6&#39;, self._madVers):
            raise IOError(&#39;listFileTimes requires Madrigal 2.6 or greater, but this site is version %s&#39; % (self._madVers))
    
        url = urlparse.urljoin(self.cgiurl,&#39;listFileTimesService.py&#39;)
        
        if expDir:
            url += &#39;?expDir=%s&#39; % (expDir)

        urlFile = urllib2.urlopen(url, timeout=TIMEOUT)
        
        retList = []

        data = urlFile.read().decode(&#39;utf-8&#39;)
        lines = data.split(&#39;\n&#39;)
        for line in lines:
            items = line.split(&#39;,&#39;)
            if len(items) != 2:
                continue
            filename = items[0].strip()[1:-1] # strip off quotes
            dt = datetime.datetime.strptime(items[1].strip(), &#39;%Y-%m-%d %H:%M:%S&#39;)
            retList.append((filename, dt))
            
        return(retList)
    
    
    def downloadWebFile(self, expPath, destination):
        &#34;&#34;&#34;downloadWebFile allows a user to download a axillary file from the web site. Used to
        download files found by listFileTimes.
        
        Requires a Madrigal 3.0 site.
        
        Inputs:
            expPath - filename relative to experiments[0-9]* directory. As returned by listFileTimes.
            destination - path to save file to
        &#34;&#34;&#34;
        # verify Madrigal site can call this command
        if self.compareVersions(&#39;3.0&#39;, self._madVers):
            raise IOError(&#39;downloadWebFile requires Madrigal 3.0 or greater, but this site is version %s&#39; % (self._madVers))
        
        url = urlparse.urljoin(self.cgiurl,&#39;downloadWebFileService.py&#39;)
        
        url += &#39;?expPath=%s&#39; % (expPath.replace(&#39; &#39;, &#39;+&#39;))
        
        urlFile = urllib2.urlopen(url, timeout=TIMEOUT2)

        data = urlFile.read()

        urlFile.close()
        
        f = open(destination, &#39;wb&#39;)

        f.write(data)

        f.close()
        
        
        
        
    def traceMagneticField(self, year, month, day, hour, minute,second,
                           inputType, outputType, alts, lats, lons,
                           model, qualifier, stopAlt=None):
        &#34;&#34;&#34;
        traceMagneticField returns a point along a magnetic field line for each
        point specified by the lists alts, lats, lons.
        Traces to either 1) conjugate point, 2) intersection with a given altitude in the
        northern or southern hemisphere, 3) to the apex, or 4) to GSM XY plane, depending on qualifier
        argument.  Uses Tsyganenko or IGRF fields, depending on model argument.
        Input arguments are either GSM or Geodetic, depending on inputType argument.
        Output arguments are either GSM or Geodetic, depending on outputType
        argument.

        Inputs:
        
            year, month, day, hour, minute, second - time at which to do the trace

            inputType  - 0 for geodetic, 1 for GSM

            outputType - 0 for geodetic, 1 for GSM
        
            The following parameter depend on inputType:
            
            alts - a list of geodetic altitudes or ZGSMs of starting point
        
            lats - a clist of geodetic latitudes or XGSMs of starting point
        
            lons - a list of longitude or YGSM of starting point

            Length of all three lists must be the same
        
            model - 0 for Tsyganenko, 1 for IGRF
        
            qualifier - 0 for conjugate, 1 for north_alt, 2 for south_alt, 3 for apex, 4 for GSM XY plane
        
            stopAlt - altitude in km to stop trace at, if qualifier is north_alt or south_alt.
                If other qualifier, this parameter is not required. Default is None, which will raise
                exception if qualifier is north_alt or south_alt

        Returns a tuple of tuples, one tuple for point in (alts, lats, lons) lists, where each tuple has
        three items:
    
            1. geodetic altitude or ZGSM of ending point
    
            2. geodetic latitude or XGSM of ending point
    
            3. longitude or YGSM of ending point
    
    
        If error, traceback includes error description
        &#34;&#34;&#34;
        scriptName = &#39;traceMagneticFieldService.py&#39;

        url = self.cgiurl + scriptName + &#39;?&#39;
        
        delimiter = &#39;,&#39;

        # append arguments
        url += &#39;year=%i&amp;&#39; % (int(year))
        url += &#39;month=%i&amp;&#39; % (int(month))
        url += &#39;day=%i&amp;&#39; % (int(day))
        url += &#39;hour=%i&amp;&#39; % (int(hour))
        url += &#39;min=%i&amp;&#39; % (int(minute))
        url += &#39;sec=%i&amp;&#39; % (int(second))
        url += &#39;inputType=%i&amp;&#39; % (int(inputType))
        url += &#39;outputType=%i&amp;&#39; % (int(outputType))
        in1Str = delimiter.join([str(item) for item in alts])
        url += &#39;in1=%s&amp;&#39; % (in1Str)
        in2Str = delimiter.join([str(item) for item in lats])
        url += &#39;in2=%s&amp;&#39; % (in2Str)
        in3Str = delimiter.join([str(item) for item in lons])
        url += &#39;in3=%s&amp;&#39; % (in3Str)
        url += &#39;model=%i&amp;&#39; % (int(model))
        url += &#39;qualifier=%i&amp;&#39; % (int(qualifier))
        if stopAlt == None:
            if int(qualifier) in (1,2):
                raise ValueError(&#39;stopAlt must be set for qualifer in (1,2)&#39;)
            else:
                stopAlt = 0.0
        url += &#39;stopAlt=%s&#39; % (str(stopAlt))
        
        # remove any pluses in the url due to scientific notation
        url = url.replace(&#39;+&#39;, &#39;%2B&#39;)

        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
        except:
            raise ValueError(&#39;unable to open url &#39; + str(url))

        page = mainUrl.read().decode(&#39;utf8&#39;)
        page = page.split(&#39;\n&#39;)

        mainUrl.close()

        # parse the result
        if len(page) == 0:
            raise ValueError(&#39;No data found at url&#39; + str(url))

        # check that html was not returned
        for line in page:
            if line.find(&#39;Error occurred&#39;) != -1:
                raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

        result = []
        
        for line in page:
            items = line.split(&#39;,&#39;)
            if len(items) &lt; 3:
                continue
            result.append((float(items[0]),
                           float(items[1]),
                           float(items[2])))

        return result
    
    
    def getVersion(self):
        &#34;&#34;&#34;getVersion gets the version number of Madrigal in form number dot number etc.
        
        Assumes version is 2.5 if no getVersionService.py installed
        &#34;&#34;&#34;
        scriptName = &#39;getVersionService.py&#39;

        url = self.cgiurl + scriptName

        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
        except:
            # if this fails, must be 2.5
            return(&#39;2.5&#39;)

        page = mainUrl.read().decode(&#39;utf-8&#39;)

        mainUrl.close()
        
        return(page.strip())
    
    
    def compareVersions(self, ver1, ver2):
        &#34;&#34;&#34;compareVersions returns False if ver1 &lt;= ver2, 0 True otherwise
        
        Inputs: version number strings, in form number dot number (any number of dots)
        &#34;&#34;&#34;
        return(distutils.version.LooseVersion(ver1) &gt; distutils.version.LooseVersion(ver2))
            

    def getCitedFilesFromUrl(self, url):
        &#34;&#34;&#34;getCitedFilesFromUrl returns a list of citations to individual Madrigal file from a group id url
        as found in a publication
        &#34;&#34;&#34;
        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
        except:
            raise ValueError(&#39;unable to open url &#39; + str(url))

        page = mainUrl.read().decode(&#39;utf8&#39;)
        page = page.strip().split(&#39;\n&#39;)

        mainUrl.close()
        
        return(page)
    
    
    def createCitationGroupFromList(self, citationList, user_fullname, user_email, user_affiliation):
        &#34;&#34;&#34;createCitationGroupFromList creates a new group citation given an input
        list of citations in the form: 
        &#39;https://w3id.org/cedar?experiment_list=experiments/2014/mlh/16mar13&amp;file_list=mlh130316g.007.hdf5&#39;
        or &#39;experiments/2014/mlh/16mar13&amp;file_list=mlh130316g.007.hdf5&#39;
        
        Inputs:
        
            citationList - list of citations
        
            user_fullname - full name of user making request

            user_email - email address of user making request

            user_affiliation - affiliation of user making request
            
        Returns:
        
            group citation (string)
        &#34;&#34;&#34;
        url = &#39;http://cedar.openmadrigal.org/createCitationGroupWithList?&#39;
        # temp only - until cedar updated
        #url = &#39;http://127.0.0.1:8000/createCitationGroupWithList?&#39;
        user_fullname = user_fullname.replace(&#39; &#39;,&#39;+&#39;).strip()
        url += &#39;user_fullname=%s&amp;&#39; % (user_fullname)
        user_email = user_email.strip()
        url += &#39;user_email=%s&amp;&#39; % (user_email)
        user_affiliation = user_affiliation.replace(&#39; &#39;,&#39;+&#39;).strip()
        url += &#39;user_affiliation=%s&amp;&#39; % (user_affiliation)
        for citation in citationList:
            if not citation == citationList[-1]:
                url += &#39;url=%s&amp;&#39; % (urlparse.quote_plus(citation))
            else:
                url += &#39;url=%s&#39; % (urlparse.quote_plus(citation))
        
        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
        except:
            raise ValueError(&#39;unable to open url &#39; + str(url))

        page = mainUrl.read().decode(&#39;utf8&#39;)
        page = page.strip()

        mainUrl.close()
        
        return(page)
    
    
    def getCitationListFromFilters(self, startDate, endDate, inst=None, kindat=None, 
                           seasonalStartDate=None, seasonalEndDate=None, 
                           includeNonDefault=False, expName=None, excludeExpName=None, 
                           fileDesc=None):
        &#34;&#34;&#34;getCitationListFromFilters returns a list of citations using filters similar to globalDownload.
        Result can then be used to create citation group using createCitationGroupFromList 
        
        Inputs:
                startDate: start datetime to filter experiments before in YYYY-MM-DD (required)
                endDate: end datetime to filter experiments after  in YYYY-MM-DD (required)
                inst: a list of instrument codes or names. If None, all instruments used. 
                    For names fnmatch will be used
                kindat: a list of kind of data codes or names. If None, all kindats used. 
                    For names fnmatch will be used
                seasonalStartDate: in form MM/DD, rejects all days earlier in year. If None,
                    implies 01/01
                seasonalEndDate: in form MM/DD, rejects all days later in year. If None,
                    implies 12/31
                includeNonDefault: if set, include realtime files when there are no default. If False,
                    implies only default files.
                expName: string - filter experiments by the experiment name.  fnmatch rules
                    If None, no filtering by experiment name.
                excludeExpName: string - exclude experiments by the experiment name.  fnmatch rules  
                    If None, no excluding experiments by experiment name.
                fileDesc: filter files using input file Description string via fnmatch. 
                    If None, no filtering by file name
        
        Returns a list with all citations in group, which can be used in createCitationGroupFromList
        &#34;&#34;&#34;
        url = &#39;http://cedar.openmadrigal.org/getCitationGroupWithFilters?&#39;
        # temp only - until cedar updated
        # url = &#39;http://127.0.0.1:8000/getCitationGroupWithFilters?&#39;
        url += &#39;startDate=%s&amp;&#39; % (startDate.strftime(&#39;%Y-%m-%d&#39;))
        url += &#39;endDate=%s&amp;&#39; % (endDate.strftime(&#39;%Y-%m-%d&#39;))
        if not inst is None:
            for thisInst in inst:
                url += &#39;inst=%s&amp;&#39; % (urlparse.quote_plus(str(thisInst)))
        if not kindat is None:
            for thisKindat in kindat:
                url += &#39;kindat=%s&amp;&#39; % (urlparse.quote_plus(str(thisKindat)))
        if not seasonalStartDate is None:
            url += &#39;seasonalStartDate=%s&amp;&#39; % (seasonalStartDate.strip())
        if not seasonalEndDate is None:
            url += &#39;seasonalEndDate=%s&amp;&#39; % (seasonalEndDate.strip())
        if includeNonDefault:
            url += &#39;includeNonDefault=True&amp;&#39;
        if not expName is None:
            url += &#39;expName=%s&amp;&#39; % (urlparse.quote_plus(expName.strip()))
        if not excludeExpName is None:
            url += &#39;excludeExpName=%s&amp;&#39; % (urlparse.quote_plus(excludeExpName.strip()))
        if not fileDesc is None:
            url += &#39;fileDesc=%s&amp;&#39; % (urlparse.quote_plus(fileDesc.strip()))
            
            
        # read main url
        try:
            mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
        except:
            raise ValueError(&#39;unable to open url &#39; + str(url))

        page = mainUrl.read().decode(&#39;utf8&#39;)
        page = page.strip().split(&#39;\n&#39;)

        mainUrl.close()
        
        return(page)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="madrigalWeb.madrigalWeb.MadrigalData.compareVersions"><code class="name flex">
<span>def <span class="ident">compareVersions</span></span>(<span>self, ver1, ver2)</span>
</code></dt>
<dd>
<div class="desc"><p>compareVersions returns False if ver1 &lt;= ver2, 0 True otherwise</p>
<p>Inputs: version number strings, in form number dot number (any number of dots)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compareVersions(self, ver1, ver2):
    &#34;&#34;&#34;compareVersions returns False if ver1 &lt;= ver2, 0 True otherwise
    
    Inputs: version number strings, in form number dot number (any number of dots)
    &#34;&#34;&#34;
    return(distutils.version.LooseVersion(ver1) &gt; distutils.version.LooseVersion(ver2))</code></pre>
</details>
</dd>
<dt id="madrigalWeb.madrigalWeb.MadrigalData.createCitationGroupFromList"><code class="name flex">
<span>def <span class="ident">createCitationGroupFromList</span></span>(<span>self, citationList, user_fullname, user_email, user_affiliation)</span>
</code></dt>
<dd>
<div class="desc"><p>createCitationGroupFromList creates a new group citation given an input
list of citations in the form:
'https://w3id.org/cedar?experiment_list=experiments/2014/mlh/16mar13&amp;file_list=mlh130316g.007.hdf5'
or 'experiments/2014/mlh/16mar13&amp;file_list=mlh130316g.007.hdf5'</p>
<h2 id="inputs">Inputs</h2>
<p>citationList - list of citations</p>
<p>user_fullname - full name of user making request</p>
<p>user_email - email address of user making request</p>
<p>user_affiliation - affiliation of user making request</p>
<h2 id="returns">Returns</h2>
<p>group citation (string)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createCitationGroupFromList(self, citationList, user_fullname, user_email, user_affiliation):
    &#34;&#34;&#34;createCitationGroupFromList creates a new group citation given an input
    list of citations in the form: 
    &#39;https://w3id.org/cedar?experiment_list=experiments/2014/mlh/16mar13&amp;file_list=mlh130316g.007.hdf5&#39;
    or &#39;experiments/2014/mlh/16mar13&amp;file_list=mlh130316g.007.hdf5&#39;
    
    Inputs:
    
        citationList - list of citations
    
        user_fullname - full name of user making request

        user_email - email address of user making request

        user_affiliation - affiliation of user making request
        
    Returns:
    
        group citation (string)
    &#34;&#34;&#34;
    url = &#39;http://cedar.openmadrigal.org/createCitationGroupWithList?&#39;
    # temp only - until cedar updated
    #url = &#39;http://127.0.0.1:8000/createCitationGroupWithList?&#39;
    user_fullname = user_fullname.replace(&#39; &#39;,&#39;+&#39;).strip()
    url += &#39;user_fullname=%s&amp;&#39; % (user_fullname)
    user_email = user_email.strip()
    url += &#39;user_email=%s&amp;&#39; % (user_email)
    user_affiliation = user_affiliation.replace(&#39; &#39;,&#39;+&#39;).strip()
    url += &#39;user_affiliation=%s&amp;&#39; % (user_affiliation)
    for citation in citationList:
        if not citation == citationList[-1]:
            url += &#39;url=%s&amp;&#39; % (urlparse.quote_plus(citation))
        else:
            url += &#39;url=%s&#39; % (urlparse.quote_plus(citation))
    
    # read main url
    try:
        mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
    except:
        raise ValueError(&#39;unable to open url &#39; + str(url))

    page = mainUrl.read().decode(&#39;utf8&#39;)
    page = page.strip()

    mainUrl.close()
    
    return(page)</code></pre>
</details>
</dd>
<dt id="madrigalWeb.madrigalWeb.MadrigalData.downloadFile"><code class="name flex">
<span>def <span class="ident">downloadFile</span></span>(<span>self, filename, destination, user_fullname, user_email, user_affiliation, format='simple')</span>
</code></dt>
<dd>
<div class="desc"><p>downloadFile will download a Cedar file in the specified format.</p>
<h2 id="inputs">Inputs</h2>
<p>filename - The absolute filename to as returned via getExperimentFiles.</p>
<p>destination - where the file is to be stored</p>
<p>user_fullname - full name of user making request</p>
<p>user_email - email address of user making request</p>
<p>user_affiliation - affiliation of user making request</p>
<p>format - file format desired.
May be
'simple', 'hdf5', 'netCDF4',
'madrigal', 'blockedBinary', 'ncar',
'unblockedBinary', or 'ascii'.
Default is 'simple'
Simple is a simple ascii space delimited column format.
Simple and hdf5 are recommended since they are standard formats</p>
<pre><code>hdf5 format works for Madrigal 2.6 or later
netCDF4 format works for Madrigal 3.0 or later
madrigal', 'blockedBinary', 'ncar',
 'unblockedBinary', or 'ascii' no longer supported for Madrigal 3.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def downloadFile(self, filename, destination, user_fullname, user_email, user_affiliation, 
                 format=&#39;simple&#39;):
    &#34;&#34;&#34;downloadFile will download a Cedar file in the specified format.

    Inputs:

        filename - The absolute filename to as returned via getExperimentFiles.

        destination - where the file is to be stored
        
        user_fullname - full name of user making request

        user_email - email address of user making request

        user_affiliation - affiliation of user making request

        format - file format desired.  May be  &#39;simple&#39;, &#39;hdf5&#39;, &#39;netCDF4&#39;,
            &#39;madrigal&#39;, &#39;blockedBinary&#39;, &#39;ncar&#39;,
             &#39;unblockedBinary&#39;, or &#39;ascii&#39;.  Default is &#39;simple&#39;
             Simple is a simple ascii space delimited column format.
             Simple and hdf5 are recommended since they are standard formats
                 
            hdf5 format works for Madrigal 2.6 or later
            netCDF4 format works for Madrigal 3.0 or later
            madrigal&#39;, &#39;blockedBinary&#39;, &#39;ncar&#39;,
             &#39;unblockedBinary&#39;, or &#39;ascii&#39; no longer supported for Madrigal 3.

    &#34;&#34;&#34;
    fileType = 0
    if format not in (&#39;hdf5&#39;, &#39;madrigal&#39;, &#39;blockedBinary&#39;, &#39;ncar&#39;, 
                      &#39;unblockedBinary&#39;, &#39;ascii&#39;, &#39;simple&#39;, &#39;netCDF4&#39;):
        raise ValueError(&#39;Illegal format specified: %s&#39; % (str(format)))
    if format == &#39;blockedBinary&#39;:
        fileType = 1
    elif format == &#39;ncar&#39;:
        fileType = 2
    elif format == &#39;unblockedBinary&#39;:
        fileType = 3
    elif format == &#39;simple&#39;:
        fileType = -1
    elif format == &#39;hdf5&#39;:
        # verify Madrigal site can handle this argument
        if self.compareVersions(&#39;2.6&#39;, self._madVers):
            raise IOError(&#39;downloadFile with hdf5 format requires Madrigal 2.6 or greater, but this site is version %s&#39; % (self._madVers))
        fileType = -2
    elif format == &#39;netCDF4&#39;:
        # verify Madrigal site can handle this argument
        if self.compareVersions(&#39;3.0&#39;, self._madVers):
            raise IOError(&#39;downloadFile with netCDF4 format requires Madrigal 3.0 or greater, but this site is version %s&#39; % (self._madVers))
        fileType = -3
    else:
        fileType = 4
        
    # verify no old formats specified if Madrigal 3
    if fileType &gt; 0:
        if not self.compareVersions(&#39;3.0&#39;, self._madVers):
            raise IOError(&#39;Only Madrigal 2.X sites can create old style files, but this site is version %s&#39; % (self._madVers))

    
    url = urlparse.urljoin(self.cgiurl,&#39;getMadfile.cgi?fileName=%s&amp;fileType=%i&amp;&#39; % (filename, fileType))
    user_fullname = user_fullname.replace(&#39; &#39;,&#39;+&#39;).strip()
    url += &#39;user_fullname=%s&amp;&#39; % (user_fullname)
    user_email = user_email.strip()
    url += &#39;user_email=%s&amp;&#39; % (user_email)
    user_affiliation = user_affiliation.replace(&#39; &#39;,&#39;+&#39;).strip()
    url += &#39;user_affiliation=%s&#39; % (user_affiliation)
    
    CHUNK = 16 * 1024

    urlFile = urllib2.urlopen(url, timeout=TIMEOUT)
    
    if format in (&#39;ascii&#39;, &#39;simple&#39;):
        f = open(destination, &#39;w&#39;)
    else:
        f = open(destination, &#39;wb&#39;)

    while(True):
        if format in (&#39;ascii&#39;, &#39;simple&#39;):
            try:
                data = urlFile.read(CHUNK).decode(&#39;utf8&#39;)
            except:
                # probably gzip ascii - convert
                f.close()
                try:
                    os.remove(destination)
                except:
                    pass
                urlFile.close()
                urlFile = urllib2.urlopen(url, timeout=TIMEOUT)
                f = open(destination + &#39;.gz&#39;, &#39;wb&#39;)
                format = &#39;gzip&#39;
                data = urlFile.read(CHUNK)
                
        else:
            data = urlFile.read(CHUNK)
        if not data:
            break
        f.write(data)
        
    urlFile.close()
    
    f.close()</code></pre>
</details>
</dd>
<dt id="madrigalWeb.madrigalWeb.MadrigalData.downloadWebFile"><code class="name flex">
<span>def <span class="ident">downloadWebFile</span></span>(<span>self, expPath, destination)</span>
</code></dt>
<dd>
<div class="desc"><p>downloadWebFile allows a user to download a axillary file from the web site. Used to
download files found by listFileTimes.</p>
<p>Requires a Madrigal 3.0 site.</p>
<h2 id="inputs">Inputs</h2>
<p>expPath - filename relative to experiments[0-9]* directory. As returned by listFileTimes.
destination - path to save file to</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def downloadWebFile(self, expPath, destination):
    &#34;&#34;&#34;downloadWebFile allows a user to download a axillary file from the web site. Used to
    download files found by listFileTimes.
    
    Requires a Madrigal 3.0 site.
    
    Inputs:
        expPath - filename relative to experiments[0-9]* directory. As returned by listFileTimes.
        destination - path to save file to
    &#34;&#34;&#34;
    # verify Madrigal site can call this command
    if self.compareVersions(&#39;3.0&#39;, self._madVers):
        raise IOError(&#39;downloadWebFile requires Madrigal 3.0 or greater, but this site is version %s&#39; % (self._madVers))
    
    url = urlparse.urljoin(self.cgiurl,&#39;downloadWebFileService.py&#39;)
    
    url += &#39;?expPath=%s&#39; % (expPath.replace(&#39; &#39;, &#39;+&#39;))
    
    urlFile = urllib2.urlopen(url, timeout=TIMEOUT2)

    data = urlFile.read()

    urlFile.close()
    
    f = open(destination, &#39;wb&#39;)

    f.write(data)

    f.close()</code></pre>
</details>
</dd>
<dt id="madrigalWeb.madrigalWeb.MadrigalData.geodeticToRadar"><code class="name flex">
<span>def <span class="ident">geodeticToRadar</span></span>(<span>self, slatgd, slon, saltgd, gdlat, glon, gdalt)</span>
</code></dt>
<dd>
<div class="desc"><p>geodeticToRadar converts arrays of points in space to az, el, and range.</p>
<p>Input arguments:</p>
<pre><code>1. slatgd - radar geodetic latitude

2. slon - radar longitude

3. saltgd - radar altitude

4. gdlat - either a single geodetic latitude, or a list of geodetic latitudes

5. glon - either a single longitude, or a list of longitudes.  If so, len(gdlat)
          must = len(glon)

6. gdalt - either a single deodetic altitude, or a list of geodetic altitudes.
           If so, len(gdalt) must = len(gdlat)
</code></pre>
<h2 id="returns">Returns</h2>
<p>A list of lists, where each list contains 3 floats (az, el, and range)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def geodeticToRadar(self,
                    slatgd,
                    slon,
                    saltgd,
                    gdlat,
                    glon,
                    gdalt):
    &#34;&#34;&#34;geodeticToRadar converts arrays of points in space to az, el, and range.

    Input arguments:

        1. slatgd - radar geodetic latitude 

        2. slon - radar longitude 

        3. saltgd - radar altitude
        
        4. gdlat - either a single geodetic latitude, or a list of geodetic latitudes 

        5. glon - either a single longitude, or a list of longitudes.  If so, len(gdlat)
                  must = len(glon)

        6. gdalt - either a single deodetic altitude, or a list of geodetic altitudes.
                   If so, len(gdalt) must = len(gdlat)


    Returns:

        A list of lists, where each list contains 3 floats (az, el, and range)
    &#34;&#34;&#34;
    scriptName = &#39;geodeticToRadarService.py&#39;

    url = self.cgiurl + scriptName + &#39;?slatgd&#39;

    # append arguments
    url += &#39;=%f&amp;slon&#39; % (float(slatgd))
    url += &#39;=%f&amp;saltgd&#39; % (float(slon))
    url += &#39;=%f&amp;&#39; % (float(saltgd))

    if type(gdlat) == list or type(gdlat) == tuple:
        if len(gdlat) != len(glon) or len(gdlat) != len(gdalt):
            raise ValueError(&#39;all lists most have same length&#39;)
        for i in range(len(gdlat)):
            if i == 0:
                arg = str(gdlat[i])
            else:
                arg += &#39;,&#39; + str(gdlat[i])
        url += &#39;gdlat=%s&amp;&#39; % (arg)

        for i in range(len(glon)):
            if i == 0:
                arg = str(glon[i])
            else:
                arg += &#39;,&#39; + str(glon[i])
        url += &#39;glon=%s&amp;&#39; % (arg)

        for i in range(len(gdalt)):
            if i == 0:
                arg = str(gdalt[i])
            else:
                arg += &#39;,&#39; + str(gdalt[i])
        url += &#39;gdalt=%s&#39; % (arg)

    else:
        url += &#39;gdlat=%f&amp;&#39; % (gdlat)
        url += &#39;glon=%f&amp;&#39; % (glon)
        url += &#39;gdalt=%f&amp;&#39; % (gdalt)
        
    # remove any pluses in the url due to scientific notation
    url = url.replace(&#39;+&#39;, &#39;%2B&#39;)

    # read main url
    try:
        mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
    except:
        raise ValueError(&#39;unable to open url &#39; + str(url))
            
    page = mainUrl.read().decode(&#39;utf8&#39;)
    page = page.split(&#39;\n&#39;)

    mainUrl.close()

    # parse the result
    if len(page) == 0:
        raise ValueError(&#39;No data found at url&#39; + str(url))

    # check that error was not returned
    for line in page:
        if line.find(&#39;Error occurred&#39;) != -1:
            raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

    result = []

    # parse output
    for line in page:
        items = line.split(&#39;,&#39;)
        if len(items) &lt; 3:
            # blank line
            continue
        newList = []
        for item in items:
            try:
                newList.append(float(item))
            except:
                newList.append(str(item))
        result.append(newList)

    return result</code></pre>
</details>
</dd>
<dt id="madrigalWeb.madrigalWeb.MadrigalData.getAllInstruments"><code class="name flex">
<span>def <span class="ident">getAllInstruments</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns a list of all MadrigalInstruments at the given Madrigal site</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAllInstruments(self):
    &#34;&#34;&#34; returns a list of all MadrigalInstruments at the given Madrigal site&#34;&#34;&#34;

    scriptName = &#39;getInstrumentsService.py&#39;

    url = self.cgiurl + scriptName

    # read main url
    try:
        mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
    except:
        raise ValueError(&#39;unable to open url &#39; + str(url))

    page = mainUrl.read().decode(&#39;utf8&#39;)
    page = page.split(&#39;\n&#39;)

    mainUrl.close()

    # parse the result
    if len(page) == 0:
        raise ValueError(&#39;No data found at url&#39; + str(url))

    # check that html was not returned
    for line in page:
        if line.find(&#39;Error occurred&#39;) != -1:
            raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

    result = []

    for line in page:
        items = line.split(&#39;,&#39;)
        if len(items) &lt; 5:
            continue
        if len(items) &gt; 6:
            category = items[6]
        else:
            category = &#39;unknown&#39;
        result.append(MadrigalInstrument(items[0],
                                         items[1],
                                         items[2],
                                         items[3],
                                         items[4],
                                         items[5],
                                         category))

    return result</code></pre>
</details>
</dd>
<dt id="madrigalWeb.madrigalWeb.MadrigalData.getCitationListFromFilters"><code class="name flex">
<span>def <span class="ident">getCitationListFromFilters</span></span>(<span>self, startDate, endDate, inst=None, kindat=None, seasonalStartDate=None, seasonalEndDate=None, includeNonDefault=False, expName=None, excludeExpName=None, fileDesc=None)</span>
</code></dt>
<dd>
<div class="desc"><p>getCitationListFromFilters returns a list of citations using filters similar to globalDownload.
Result can then be used to create citation group using createCitationGroupFromList </p>
<h2 id="inputs">Inputs</h2>
<p>startDate: start datetime to filter experiments before in YYYY-MM-DD (required)
endDate: end datetime to filter experiments after
in YYYY-MM-DD (required)
inst: a list of instrument codes or names. If None, all instruments used.
For names fnmatch will be used
kindat: a list of kind of data codes or names. If None, all kindats used.
For names fnmatch will be used
seasonalStartDate: in form MM/DD, rejects all days earlier in year. If None,
implies 01/01
seasonalEndDate: in form MM/DD, rejects all days later in year. If None,
implies 12/31
includeNonDefault: if set, include realtime files when there are no default. If False,
implies only default files.
expName: string - filter experiments by the experiment name.
fnmatch rules
If None, no filtering by experiment name.
excludeExpName: string - exclude experiments by the experiment name.
fnmatch rules<br>
If None, no excluding experiments by experiment name.
fileDesc: filter files using input file Description string via fnmatch.
If None, no filtering by file name</p>
<p>Returns a list with all citations in group, which can be used in createCitationGroupFromList</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCitationListFromFilters(self, startDate, endDate, inst=None, kindat=None, 
                       seasonalStartDate=None, seasonalEndDate=None, 
                       includeNonDefault=False, expName=None, excludeExpName=None, 
                       fileDesc=None):
    &#34;&#34;&#34;getCitationListFromFilters returns a list of citations using filters similar to globalDownload.
    Result can then be used to create citation group using createCitationGroupFromList 
    
    Inputs:
            startDate: start datetime to filter experiments before in YYYY-MM-DD (required)
            endDate: end datetime to filter experiments after  in YYYY-MM-DD (required)
            inst: a list of instrument codes or names. If None, all instruments used. 
                For names fnmatch will be used
            kindat: a list of kind of data codes or names. If None, all kindats used. 
                For names fnmatch will be used
            seasonalStartDate: in form MM/DD, rejects all days earlier in year. If None,
                implies 01/01
            seasonalEndDate: in form MM/DD, rejects all days later in year. If None,
                implies 12/31
            includeNonDefault: if set, include realtime files when there are no default. If False,
                implies only default files.
            expName: string - filter experiments by the experiment name.  fnmatch rules
                If None, no filtering by experiment name.
            excludeExpName: string - exclude experiments by the experiment name.  fnmatch rules  
                If None, no excluding experiments by experiment name.
            fileDesc: filter files using input file Description string via fnmatch. 
                If None, no filtering by file name
    
    Returns a list with all citations in group, which can be used in createCitationGroupFromList
    &#34;&#34;&#34;
    url = &#39;http://cedar.openmadrigal.org/getCitationGroupWithFilters?&#39;
    # temp only - until cedar updated
    # url = &#39;http://127.0.0.1:8000/getCitationGroupWithFilters?&#39;
    url += &#39;startDate=%s&amp;&#39; % (startDate.strftime(&#39;%Y-%m-%d&#39;))
    url += &#39;endDate=%s&amp;&#39; % (endDate.strftime(&#39;%Y-%m-%d&#39;))
    if not inst is None:
        for thisInst in inst:
            url += &#39;inst=%s&amp;&#39; % (urlparse.quote_plus(str(thisInst)))
    if not kindat is None:
        for thisKindat in kindat:
            url += &#39;kindat=%s&amp;&#39; % (urlparse.quote_plus(str(thisKindat)))
    if not seasonalStartDate is None:
        url += &#39;seasonalStartDate=%s&amp;&#39; % (seasonalStartDate.strip())
    if not seasonalEndDate is None:
        url += &#39;seasonalEndDate=%s&amp;&#39; % (seasonalEndDate.strip())
    if includeNonDefault:
        url += &#39;includeNonDefault=True&amp;&#39;
    if not expName is None:
        url += &#39;expName=%s&amp;&#39; % (urlparse.quote_plus(expName.strip()))
    if not excludeExpName is None:
        url += &#39;excludeExpName=%s&amp;&#39; % (urlparse.quote_plus(excludeExpName.strip()))
    if not fileDesc is None:
        url += &#39;fileDesc=%s&amp;&#39; % (urlparse.quote_plus(fileDesc.strip()))
        
        
    # read main url
    try:
        mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
    except:
        raise ValueError(&#39;unable to open url &#39; + str(url))

    page = mainUrl.read().decode(&#39;utf8&#39;)
    page = page.strip().split(&#39;\n&#39;)

    mainUrl.close()
    
    return(page)</code></pre>
</details>
</dd>
<dt id="madrigalWeb.madrigalWeb.MadrigalData.getCitedFilesFromUrl"><code class="name flex">
<span>def <span class="ident">getCitedFilesFromUrl</span></span>(<span>self, url)</span>
</code></dt>
<dd>
<div class="desc"><p>getCitedFilesFromUrl returns a list of citations to individual Madrigal file from a group id url
as found in a publication</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCitedFilesFromUrl(self, url):
    &#34;&#34;&#34;getCitedFilesFromUrl returns a list of citations to individual Madrigal file from a group id url
    as found in a publication
    &#34;&#34;&#34;
    # read main url
    try:
        mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
    except:
        raise ValueError(&#39;unable to open url &#39; + str(url))

    page = mainUrl.read().decode(&#39;utf8&#39;)
    page = page.strip().split(&#39;\n&#39;)

    mainUrl.close()
    
    return(page)</code></pre>
</details>
</dd>
<dt id="madrigalWeb.madrigalWeb.MadrigalData.getExperimentFileParameters"><code class="name flex">
<span>def <span class="ident">getExperimentFileParameters</span></span>(<span>self, fullFilename)</span>
</code></dt>
<dd>
<div class="desc"><p>getExperimentFileParameters returns a list of all measured and derivable parameters in file</p>
<h2 id="inputs">Inputs</h2>
<p>fullFilename - full path to experiment file as returned by getExperimentFiles.</p>
<h2 id="outputs">Outputs</h2>
<p>List of MadrigalParameter objects for that fullFilename.
Includes both measured
and derivable parameters in file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getExperimentFileParameters(self,fullFilename):
    &#34;&#34;&#34; getExperimentFileParameters returns a list of all measured and derivable parameters in file

    Inputs:

       fullFilename - full path to experiment file as returned by getExperimentFiles.

    Outputs:

        List of MadrigalParameter objects for that fullFilename.  Includes both measured
        and derivable parameters in file.


    &#34;&#34;&#34;

    scriptName = &#39;getParametersService.py&#39;

    url = self.cgiurl + scriptName + &#39;?filename=%s&#39; % (str(fullFilename))


    # read main url
    try:
        mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
    except:
        raise ValueError(&#39;unable to open url &#39; + str(url))
            

    page = mainUrl.read().decode(&#39;utf8&#39;)
    page = page.split(&#39;\n&#39;)

    mainUrl.close()

    # parse the result
    if len(page) == 0:
        return []

    # check that error was not returned
    for line in page:
        if line.find(&#39;Error occurred&#39;) != -1:
            raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

    result = []



    for line in page:
        items = line.split(&#39;\\&#39;)
        # with Madrigal 2.5, isAddIncrement was added as 8th column
        if len(items) &lt; 7:
            continue
        try:
            isAddIncrement = int(items[7])
        except:
            isAddIncrement = -1
        result.append(MadrigalParameter(items[0],
                                        items[1],
                                        int(items[2]),
                                        items[3],
                                        int(items[4]),
                                        items[5],
                                        int(items[6]),
                                        isAddIncrement))
        

    return result</code></pre>
</details>
</dd>
<dt id="madrigalWeb.madrigalWeb.MadrigalData.getExperimentFiles"><code class="name flex">
<span>def <span class="ident">getExperimentFiles</span></span>(<span>self, id, getNonDefault=False)</span>
</code></dt>
<dd>
<div class="desc"><p>returns a list of all default MadrigalExperimentFiles for a given experiment id</p>
<h2 id="inputs">Inputs</h2>
<p>id - Experiment id.</p>
<p>getNonDefault - if False (the default), only get default files, or realtime
files if no default files found.
If True, get all files.
In general, users should set this to False because default files
are the most reliable.</p>
<h2 id="outputs">Outputs</h2>
<p>List of MadrigalExperimentFile objects for that experiment id</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getExperimentFiles(self, id, getNonDefault=False):
    &#34;&#34;&#34; returns a list of all default MadrigalExperimentFiles for a given experiment id

    Inputs:

       id - Experiment id.

       getNonDefault - if False (the default), only get default files, or realtime
                       files if no default files found.  If True, get all files.
                       In general, users should set this to False because default files
                       are the most reliable.

    Outputs:

        List of MadrigalExperimentFile objects for that experiment id


    &#34;&#34;&#34;

    scriptName = &#39;getExperimentFilesService.py&#39;
    
    if int(id) == -1:
        err_str = &#34;&#34;&#34;Illegal experiment id -1.  This is usually caused by calling
        getExperiments with the isLocal flag set to 0.  To get the experiment id for a non-local
        experiment, you will need to create a new MadrigalData object with the url of the 
        non-local experiment (MadrigalExperiment.madrigalUrl), and then call 
        getExperiments a second time using that Madrigal url.  This is because 
        while Madrigal sites share metadata about experiments, the real experiment ids are only
        known by the individual Madrigal sites. See examples/exampleMadrigalWebServices.py
        for an example of this.
        &#34;&#34;&#34;
        raise ValueError(err_str)

    url = self.cgiurl + scriptName + &#39;?id=%i&#39; % (int(id))


    # read main url
    try:
        mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
    except:
        raise ValueError(&#39;unable to open url &#39; + str(url))
            

    page = mainUrl.read().decode(&#39;utf8&#39;)
    page = page.split(&#39;\n&#39;)

    mainUrl.close()

    # parse the result
    if len(page) == 0:
        return []

    # check that error was not returned
    for line in page:
        if line.find(&#39;Error occurred&#39;) != -1:
            raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

    result = []

    # find out if no default files.  If so, return realtime also
    hasDefault = False
    for line in page:
        items = line.split(&#39;,&#39;)
        if len(items) &lt; 4:
            continue
        if int(items[3]) == 1:
            hasDefault = True
            break

    for line in page:
        items = line.split(&#39;,&#39;)
        if len(items) &lt; 4:
            continue
        category = int(items[3])
        if hasDefault and category != 1 and not getNonDefault:
            continue
        if not hasDefault and category != 4 and not getNonDefault:
            continue
        if len(items) &gt; 6:
            doi = items[6]
        else:
            doi = None
        result.append(MadrigalExperimentFile(items[0],
                                             items[1],
                                             items[2],
                                             items[3],
                                             items[4],
                                             items[5],
                                             id,
                                             doi))
        

    return result</code></pre>
</details>
</dd>
<dt id="madrigalWeb.madrigalWeb.MadrigalData.getExperiments"><code class="name flex">
<span>def <span class="ident">getExperiments</span></span>(<span>self, code, startyear, startmonth, startday, starthour, startmin, startsec, endyear, endmonth, endday, endhour, endmin, endsec, local=1)</span>
</code></dt>
<dd>
<div class="desc"><p>returns a list of all MadrigalExperiments that meet criteria at the given Madrigal site</p>
<h2 id="inputs">Inputs</h2>
<p>code - int or list of ints representing instrument code(s). Special value of 0 selects all instruments.</p>
<p>startyear - int or string convertable to int</p>
<p>startmonth - int or string convertable to int</p>
<p>startday - int or string convertable to int</p>
<p>starthour - int or string convertable to int</p>
<p>startmin - int or string convertable to int</p>
<p>startsec - int or string convertable to int</p>
<p>endyear - int or string convertable to int</p>
<p>endmonth - int or string convertable to int</p>
<p>endday - int or string convertable to int</p>
<p>endhour - int or string convertable to int</p>
<p>endmin - int or string convertable to int</p>
<p>endsec - int or string convertable to int</p>
<p>local - 0 if all sites desired, 1 (default) if only local experiments desired</p>
<h2 id="outputs">Outputs</h2>
<p>List of MadrigalExperiment objects that meet the criteria.
Note that if the returned
MadrigalExperiment is not local, the experiment id will be -1.
This means that you
will need to create a new MadrigalData object with the url of the
non-local experiment (MadrigalExperiment.madrigalUrl), and then call
getExperiments a second time using that Madrigal url.
This is because
while Madrigal sites share metadata about experiments, the real experiment ids are only
known by the individual Madrigal sites.
See examples/exampleMadrigalWebServices.py
for an example of this.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getExperiments(self,
                   code,
                   startyear,
                   startmonth,
                   startday,
                   starthour,
                   startmin,
                   startsec,
                   endyear,
                   endmonth,
                   endday,
                   endhour,
                   endmin,
                   endsec,
                   local=1):
    &#34;&#34;&#34; returns a list of all MadrigalExperiments that meet criteria at the given Madrigal site

    Inputs:

       code - int or list of ints representing instrument code(s). Special value of 0 selects all instruments.
       
       startyear - int or string convertable to int
       
       startmonth - int or string convertable to int
       
       startday - int or string convertable to int
       
       starthour - int or string convertable to int
       
       startmin - int or string convertable to int
       
       startsec - int or string convertable to int
       
       endyear - int or string convertable to int
       
       endmonth - int or string convertable to int
       
       endday - int or string convertable to int
       
       endhour - int or string convertable to int
       
       endmin - int or string convertable to int
       
       endsec - int or string convertable to int

       local - 0 if all sites desired, 1 (default) if only local experiments desired

    Outputs:

        List of MadrigalExperiment objects that meet the criteria.  Note that if the returned
        MadrigalExperiment is not local, the experiment id will be -1.  This means that you
        will need to create a new MadrigalData object with the url of the 
        non-local experiment (MadrigalExperiment.madrigalUrl), and then call 
        getExperiments a second time using that Madrigal url.  This is because 
        while Madrigal sites share metadata about experiments, the real experiment ids are only
        known by the individual Madrigal sites.  See examples/exampleMadrigalWebServices.py
        for an example of this.


    &#34;&#34;&#34;

    scriptName = &#39;getExperimentsService.py&#39;

    url = self.cgiurl + scriptName + &#39;?&#39;

    # first append code(s)
    if type(code) == list:
        for item in code:
            url += &#39;code=%i&amp;&#39; % (int(item))
    else:
        url += &#39;code=%i&amp;&#39; % (int(code))

    # append times
    url += &#39;startyear=%i&amp;&#39; % (int(startyear))
    url += &#39;startmonth=%i&amp;&#39; % (int(startmonth))
    url += &#39;startday=%i&amp;&#39; % (int(startday))
    url += &#39;starthour=%i&amp;&#39; % (int(starthour))
    url += &#39;startmin=%i&amp;&#39; % (int(startmin))
    url += &#39;startsec=%i&amp;&#39; % (int(startsec))
    url += &#39;endyear=%i&amp;&#39; % (int(endyear))
    url += &#39;endmonth=%i&amp;&#39; % (int(endmonth))
    url += &#39;endday=%i&amp;&#39; % (int(endday))
    url += &#39;endhour=%i&amp;&#39; % (int(endhour))
    url += &#39;endmin=%i&amp;&#39; % (int(endmin))
    url += &#39;endsec=%i&amp;&#39; % (int(endsec))
    url += &#39;local=%i&#39;% (int(local))
    


    # read main url
    try:
        mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
    except:
        raise ValueError(&#39;unable to open url &#39; + str(url))
            

    

    page = mainUrl.read().decode(&#39;utf8&#39;, errors=&#39;replace&#39;)
    page = page.split(&#39;\n&#39;)

    mainUrl.close()

    # parse the result
    if len(page) == 0:
        return []

    # check that error was not returned
    for line in page:
        if line.find(&#39;Error occurred&#39;) != -1:
            raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

    result = []


    for line in page:
        items = line.split(&#39;,&#39;)
        # calculate isLocal
        if len(items) &lt; 20:
            continue
        if int(items[3]) == self.siteId:
            isLocal = True
        else:
            isLocal = False
        if isLocal:
            expIdStr = items[0]
        else:
            expIdStr = &#39;-1&#39;
        if len(items) &gt; 21:
            pi = items[20]
            piEmail = items[21]
        else:
            pi = &#39;unknown&#39;
            piEmail = &#39;unknown&#39;
        if len(items) &gt; 23:
            uttimestamp = int(items[22])
            access = int(items[23])
        else:
            uttimestamp = None
            access = None
            
        result.append(MadrigalExperiment(expIdStr,
                                         items[1],
                                         items[2],
                                         items[3],
                                         items[4],
                                         items[5],
                                         items[6],
                                         items[7],
                                         items[8],
                                         items[9],
                                         items[10],
                                         items[11],
                                         items[12],
                                         items[13],
                                         items[14],
                                         items[15],
                                         items[16],
                                         items[17],
                                         items[18],
                                         isLocal,
                                         self.siteDict[int(items[3])],
                                         pi,
                                         piEmail,
                                         uttimestamp,
                                         access,
                                         self._madVers))
        

    return result</code></pre>
</details>
</dd>
<dt id="madrigalWeb.madrigalWeb.MadrigalData.getVersion"><code class="name flex">
<span>def <span class="ident">getVersion</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>getVersion gets the version number of Madrigal in form number dot number etc.</p>
<p>Assumes version is 2.5 if no getVersionService.py installed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getVersion(self):
    &#34;&#34;&#34;getVersion gets the version number of Madrigal in form number dot number etc.
    
    Assumes version is 2.5 if no getVersionService.py installed
    &#34;&#34;&#34;
    scriptName = &#39;getVersionService.py&#39;

    url = self.cgiurl + scriptName

    # read main url
    try:
        mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
    except:
        # if this fails, must be 2.5
        return(&#39;2.5&#39;)

    page = mainUrl.read().decode(&#39;utf-8&#39;)

    mainUrl.close()
    
    return(page.strip())</code></pre>
</details>
</dd>
<dt id="madrigalWeb.madrigalWeb.MadrigalData.isprint"><code class="name flex">
<span>def <span class="ident">isprint</span></span>(<span>self, filename, parms, filters, user_fullname, user_email, user_affiliation, outputFile=None)</span>
</code></dt>
<dd>
<div class="desc"><p>returns as a string the isprint output given filename, parms, filters without headers or summary.</p>
<h2 id="inputs">Inputs</h2>
<p>filename - The absolute filename to be analyzed by isprint.</p>
<p>parms - Comma delimited string listing requested parameters (no spaces allowed).</p>
<p>filters - Space delimited string listing filters desired, as in isprint command</p>
<p>user_fullname - full name of user making request</p>
<p>user_email - email address of user making request</p>
<p>user_affiliation - affiliation of user making request</p>
<p>outputFile - if not None, download the results to outputFile.
If outputFile has an extension
of .h5, .hdf, or .hdf5, will download in Madrigal Hdf5 format.
If it has a .nc extension, will
download as netCDF4. Otherwise, it will download as column delimited ascii.
Trying to save as Hdf5 or netCDF4 with a Madrigal 2 site will raise an exception</p>
<h2 id="returns">Returns</h2>
<p>a string holding the isprint output</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isprint(self, filename, parms, filters, user_fullname, user_email, user_affiliation, outputFile=None):
    &#34;&#34;&#34;returns as a string the isprint output given filename, parms, filters without headers or summary.

    Inputs:

        filename - The absolute filename to be analyzed by isprint.

        parms - Comma delimited string listing requested parameters (no spaces allowed).

        filters - Space delimited string listing filters desired, as in isprint command

        user_fullname - full name of user making request

        user_email - email address of user making request

        user_affiliation - affiliation of user making request
        
        outputFile - if not None, download the results to outputFile.  If outputFile has an extension
            of .h5, .hdf, or .hdf5, will download in Madrigal Hdf5 format.  If it has a .nc extension, will
            download as netCDF4. Otherwise, it will download as column delimited ascii.
            Trying to save as Hdf5 or netCDF4 with a Madrigal 2 site will raise an exception

    Returns:
    
        a string holding the isprint output
    &#34;&#34;&#34;
    
    scriptName = &#39;isprintService.py&#39;

    # build the complete cgi string, replacing characters as required by cgi standard

    url = self.cgiurl + scriptName + &#39;?&#39;

    
    url += &#39;file=%s&amp;&#39; % (filename.replace(&#39;/&#39;, &#39;%2F&#39;))
    if parms.find(&#39; &#39;) != -1:
        parms = parms.replace(&#39; &#39;, &#39;&#39;) # remove all spaces
    parms = parms.replace(&#39;+&#39;,&#39;%2B&#39;)
    parms = parms.replace(&#39;,&#39;,&#39;+&#39;)
    url += &#39;parms=%s&amp;&#39; % (parms)
    filters = filters.replace(&#39;=&#39;,&#39;%3D&#39;)
    filters = filters.replace(&#39;,&#39;,&#39;%2C&#39;)
    filters = filters.replace(&#39;/&#39;,&#39;%2F&#39;)
    filters = filters.replace(&#39;+&#39;,&#39;%2B&#39;)
    filters = filters.replace(&#39; &#39;,&#39;+&#39;)
    url += &#39;filters=%s&amp;&#39; % (filters)
    user_fullname = user_fullname.replace(&#39; &#39;,&#39;+&#39;).strip()
    url += &#39;user_fullname=%s&amp;&#39; % (user_fullname)
    user_email = user_email.strip()
    url += &#39;user_email=%s&amp;&#39; % (user_email)
    user_affiliation = user_affiliation.replace(&#39; &#39;,&#39;+&#39;).strip()
    url += &#39;user_affiliation=%s&#39; % (user_affiliation)
    if not outputFile is None:
        url += &#39;&amp;output=%s&#39; % (os.path.basename(outputFile))
        filename, file_extension = os.path.splitext(outputFile)
        if file_extension in (&#39;.hdf5&#39;, &#39;.h5&#39;, &#39;.hdf&#39;):
            format = &#39;Hdf5&#39;
        elif file_extension in (&#39;.nc&#39;,):
            format = &#39;netCDF4&#39;
        else:
            format = &#39;ascii&#39;
        # if Hdf5 or netCDF4, make sure site is 3 or greater
        if format in (&#39;Hdf5&#39;, &#39;netCDF4&#39;):
            version = self.getVersion()
            if distutils.version.LooseVersion(version) &lt; distutils.version.LooseVersion(&#39;3.0&#39;):
                raise ValueError(&#39;Madrigal site at %s is below 3.0, cannot convert to Hdf5 or netCDF4&#39; % (self.cgiurl))
    else:
        format = &#39;ascii&#39;

    # read main url
    try:
        mainUrl = urllib2.urlopen(url, timeout=TIMEOUT)
    except:
        raise ValueError(&#39;unable to open url &#39; + str(url))
            
    if format == &#39;ascii&#39;:
        page = mainUrl.read().decode(&#39;utf-8&#39;)
    else:
        page = mainUrl.read()

    mainUrl.close()

    if format == &#39;ascii&#39;:
        if page.find(&#39;Error occurred&#39;) != -1:
            raise ValueError(&#39;error raised using url &#39; + str(url))

    if outputFile is None:
        return page
    
    else:
        if format == &#39;ascii&#39;:
            f = open(outputFile, &#39;w&#39;)
        else:
            f = open(outputFile, &#39;wb&#39;)
        f.write(page)
        f.close()</code></pre>
</details>
</dd>
<dt id="madrigalWeb.madrigalWeb.MadrigalData.listFileTimes"><code class="name flex">
<span>def <span class="ident">listFileTimes</span></span>(<span>self, expDir=None)</span>
</code></dt>
<dd>
<div class="desc"><p>listFileTimes lists the filenames and last modification times for all files in a Madrigal database.</p>
<p>Inputs: expDir - experiment directory to which to start.
May be any directory or subdirectory below
experiments[0-9]<em>.
Path may be absolute or relative to experiments[0-9]</em>.
If None (the default),
include entire experiments[0-9]* directory(s).
Examples: ('/opt/madrigal/experiments/1998',
'experiments/2002/gps')</p>
<p>Returns: a list of tuple of 1. filename relative to experiments[0-9]* directory, and 2) datetime in UT of
last file modification</p>
<p>Requires:
Madrigal 2.6 or greater</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def listFileTimes(self, expDir=None):
    &#34;&#34;&#34;listFileTimes lists the filenames and last modification times for all files in a Madrigal database.

    Inputs: expDir - experiment directory to which to start.  May be any directory or subdirectory below 
        experiments[0-9]*.  Path may be absolute or relative to experiments[0-9]*.  If None (the default),
        include entire experiments[0-9]* directory(s).  Examples: (&#39;/opt/madrigal/experiments/1998&#39;,
        &#39;experiments/2002/gps&#39;)
        
    Returns: a list of tuple of 1. filename relative to experiments[0-9]* directory, and 2) datetime in UT of 
        last file modification
        
    Requires:  Madrigal 2.6 or greater
    &#34;&#34;&#34;
    # verify Madrigal site can call this command
    if self.compareVersions(&#39;2.6&#39;, self._madVers):
        raise IOError(&#39;listFileTimes requires Madrigal 2.6 or greater, but this site is version %s&#39; % (self._madVers))

    url = urlparse.urljoin(self.cgiurl,&#39;listFileTimesService.py&#39;)
    
    if expDir:
        url += &#39;?expDir=%s&#39; % (expDir)

    urlFile = urllib2.urlopen(url, timeout=TIMEOUT)
    
    retList = []

    data = urlFile.read().decode(&#39;utf-8&#39;)
    lines = data.split(&#39;\n&#39;)
    for line in lines:
        items = line.split(&#39;,&#39;)
        if len(items) != 2:
            continue
        filename = items[0].strip()[1:-1] # strip off quotes
        dt = datetime.datetime.strptime(items[1].strip(), &#39;%Y-%m-%d %H:%M:%S&#39;)
        retList.append((filename, dt))
        
    return(retList)</code></pre>
</details>
</dd>
<dt id="madrigalWeb.madrigalWeb.MadrigalData.madCalculator"><code class="name flex">
<span>def <span class="ident">madCalculator</span></span>(<span>self, year, month, day, hour, min, sec, startLat, endLat, stepLat, startLong, endLong, stepLong, startAlt, endAlt, stepAlt, parms, oneDParmList=[], oneDParmValues=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Input arguments:</p>
<pre><code>1. year - int

2. month - int

3. day - int

4. hour - int

5. min - int

6. sec - int

7. startLat - Starting geodetic latitude, -90 to 90 (float)

8. endLat - Ending geodetic latitude, -90 to 90 (float)

9. stepLat - Latitude step (0.1 to 90) (float)

10. startLong - Starting geodetic longitude, -180 to 180  (float)

11. endLong - Ending geodetic longitude, -180 to 180 (float)

12. stepLong - Longitude step (0.1 to 180) (float)

13. startAlt - Starting geodetic altitude, &gt;= 0 (float)

14. endAlt - Ending geodetic altitude, &gt; 0 (float)

15. stepAlt - Altitude step (&gt;= 0.1) (float)

16. parms - comma delimited string of Madrigal parameters desired

17. oneDParmList - a list of one-D parameters whose values should
                   be set for the calculation.  Can be codes or mnemonics.
                   Defaults to empty list.

18. oneDParmValues - a list of values (doubles) associated with the one-D
                     parameters specified in oneDParmList. Defaults to empty list.
</code></pre>
<h2 id="returns">Returns</h2>
<p>A list of lists of doubles, where each list contains 3 + number of parameters doubles.
The first three doubles are the input latitude, longitude, and altitude.
The rest of the
doubles are the values of each of the calculated values.
If the value cannot be calculated,
it will be set to nan.</p>
<p>Example:</p>
<pre><code>result = testData.madCalculator(1999,2,15,12,30,0,45,55,5,-170,-150,10,200,200,0,'bmag,bn')

result = [  [45.0, -170.0, 200.0, 4.1315700000000002e-05, 2.1013500000000001e-05]
            [45.0, -160.0, 200.0, 4.2336899999999998e-05, 2.03685e-05]
            [45.0, -150.0, 200.0, 4.3856400000000002e-05, 1.97411e-05]
            [50.0, -170.0, 200.0, 4.3913599999999999e-05, 1.9639999999999998e-05]
            [50.0, -160.0, 200.0, 4.4890099999999999e-05, 1.8870999999999999e-05]
            [50.0, -150.0, 200.0, 4.6337800000000002e-05, 1.80077e-05]
            [55.0, -170.0, 200.0, 4.6397899999999998e-05, 1.78115e-05]
            [55.0, -160.0, 200.0, 4.7265400000000003e-05, 1.6932500000000001e-05]
            [55.0, -150.0, 200.0, 4.85495e-05,            1.5865399999999999e-05] ]
</code></pre>
<dl>
<dt><code>
Columns</code></dt>
<dd>
<p>gdlat
glon
gdalt
bmag
bn</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def madCalculator(self,
                  year,
                  month,
                  day,
                  hour,
                  min,
                  sec,
                  startLat,
                  endLat,
                  stepLat,
                  startLong,
                  endLong,
                  stepLong,
                  startAlt,
                  endAlt,
                  stepAlt,
                  parms,
                  oneDParmList=[],
                  oneDParmValues=[]):
    &#34;&#34;&#34;

    Input arguments:

        1. year - int 

        2. month - int 

        3. day - int
        
        4. hour - int 

        5. min - int 

        6. sec - int 

        7. startLat - Starting geodetic latitude, -90 to 90 (float)

        8. endLat - Ending geodetic latitude, -90 to 90 (float)

        9. stepLat - Latitude step (0.1 to 90) (float)

        10. startLong - Starting geodetic longitude, -180 to 180  (float)

        11. endLong - Ending geodetic longitude, -180 to 180 (float)

        12. stepLong - Longitude step (0.1 to 180) (float)

        13. startAlt - Starting geodetic altitude, &gt;= 0 (float)

        14. endAlt - Ending geodetic altitude, &gt; 0 (float)

        15. stepAlt - Altitude step (&gt;= 0.1) (float)

        16. parms - comma delimited string of Madrigal parameters desired

        17. oneDParmList - a list of one-D parameters whose values should
                           be set for the calculation.  Can be codes or mnemonics.
                           Defaults to empty list.

        18. oneDParmValues - a list of values (doubles) associated with the one-D
                             parameters specified in oneDParmList. Defaults to empty list.

    Returns:

        A list of lists of doubles, where each list contains 3 + number of parameters doubles.
        The first three doubles are the input latitude, longitude, and altitude.  The rest of the
        doubles are the values of each of the calculated values.  If the value cannot be calculated,
        it will be set to nan.

        Example:

            result = testData.madCalculator(1999,2,15,12,30,0,45,55,5,-170,-150,10,200,200,0,&#39;bmag,bn&#39;)

            result = [  [45.0, -170.0, 200.0, 4.1315700000000002e-05, 2.1013500000000001e-05]
                        [45.0, -160.0, 200.0, 4.2336899999999998e-05, 2.03685e-05]
                        [45.0, -150.0, 200.0, 4.3856400000000002e-05, 1.97411e-05]
                        [50.0, -170.0, 200.0, 4.3913599999999999e-05, 1.9639999999999998e-05]
                        [50.0, -160.0, 200.0, 4.4890099999999999e-05, 1.8870999999999999e-05]
                        [50.0, -150.0, 200.0, 4.6337800000000002e-05, 1.80077e-05]
                        [55.0, -170.0, 200.0, 4.6397899999999998e-05, 1.78115e-05]
                        [55.0, -160.0, 200.0, 4.7265400000000003e-05, 1.6932500000000001e-05]
                        [55.0, -150.0, 200.0, 4.85495e-05,            1.5865399999999999e-05] ]

            Columns:     gdlat  glon    gdalt  bmag                    bn

    &#34;&#34;&#34;

    scriptName = &#39;madCalculatorService.py&#39;

    url = self.cgiurl + scriptName + &#39;?year&#39;

    if len(oneDParmList) != len(oneDParmValues):
        raise ValueError(&#39;len(oneDParmList) != len(oneDParmValues)&#39;)
    
    if parms.find(&#39; &#39;) != -1:
        parms = parms.replace(&#39; &#39;, &#39;&#39;) # remove all spaces

    # append arguments
    url += &#39;=%i&amp;month&#39; % (int(year))
    url += &#39;=%i&amp;day&#39; % (int(month))
    url += &#39;=%i&amp;hour&#39; % (int(day))
    url += &#39;=%i&amp;min&#39; % (int(hour))
    url += &#39;=%i&amp;sec&#39; % (int(min))
    url += &#39;=%i&amp;startLat&#39; % (int(sec))
    url += &#39;=%f&amp;endLat&#39; % (float(startLat))
    url += &#39;=%f&amp;stepLat&#39; % (float(endLat))
    url += &#39;=%f&amp;startLong&#39; % (float(stepLat))
    url += &#39;=%f&amp;endLong&#39; % (float(startLong))
    url += &#39;=%f&amp;stepLong&#39; % (float(endLong))
    url += &#39;=%f&amp;startAlt&#39; % (float(stepLong))
    url += &#39;=%f&amp;endAlt&#39; % (float(startAlt))
    url += &#39;=%f&amp;stepAlt&#39; % (float(endAlt))
    url += &#39;=%f&amp;parms&#39; % (float(stepAlt))
    url += &#39;=%s&#39; % (parms)

    for i in range(len(oneDParmList)):
        url += &#39;&amp;oneD=%s,%s&#39; % (str(oneDParmList[i]), str(oneDParmValues[i]))
        
    # remove any pluses in the url due to scientific notation
    url = url.replace(&#39;+&#39;, &#39;%2B&#39;)

    # read main url
    try:
        mainUrl = urllib2.urlopen(url, timeout=TIMEOUT)
    except:
        raise ValueError(&#39;unable to open url &#39; + str(url))
            

    page = mainUrl.read().decode(&#39;utf8&#39;)
    page = page.split(&#39;\n&#39;)

    mainUrl.close()

    # parse the result
    if len(page) == 0:
        raise ValueError(&#39;No data found at url&#39; + str(url))

    # check that error was not returned
    for line in page:
        if line.find(&#39;Error occurred&#39;) != -1:
            raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

    result = []

    # parse output
    for line in page:
        items = line.split()
        if len(items) &lt; 3:
            # blank line
            continue
        newList = []
        for item in items:
            try:
                newList.append(float(item))
            except:
                newList.append(str(item))
        result.append(newList)

    return result</code></pre>
</details>
</dd>
<dt id="madrigalWeb.madrigalWeb.MadrigalData.madCalculator2"><code class="name flex">
<span>def <span class="ident">madCalculator2</span></span>(<span>self, year, month, day, hour, min, sec, latList, lonList, altList, parms, oneDParmList=[], oneDParmValues=[], twoDParmList=[], twoDParmValues=[])</span>
</code></dt>
<dd>
<div class="desc"><p>madCalculator2 is similar to madCalculator, except that a random collection of points in space can be specified,
rather than a grid of points.
Also, a user can input 2D data.</p>
<p>Added to Madrigal2.6 as web service - will not run on earlier Madrigal installations.</p>
<p>Input arguments:</p>
<pre><code>1. year - int

2. month - int

3. day - int

4. hour - int

5. min - int

6. sec - int

7. latList - a list of geodetic latitudes, -90 to 90

8. lonList - a list of longitudes, -180 to 180. Length must = lats

9. altList - a list of geodetic altitudes in km. Length must = lats

10. parms - comma delimited string of Madrigal parameters desired

11. oneDParmList - a list of one-D parameters whose values should
                   be set for the calculation.  Can be codes or mnemonics.
                   Defaults to empty list.

12. oneDParmValues - a list of values (doubles) associated with the one-D
                     parameters specified in oneDParmList. Defaults to empty list.

13. twoDParmList - a python list of two-D parameters as mnemonics.  Defaults to [].

14. twoDParmValues - a python list of lists of len = len(twoDParmList). Each individual 
                 list is a list of doubles representing values of the two-D
                 parameter set in twoDParmList, with a length = number 
                 of points (or equal to len(lats)). Defaults to [].
</code></pre>
<h2 id="returns">Returns</h2>
<p>A list of lists of doubles, where each list contains 3 + number of parameters doubles.
The first three doubles are the input latitude, longitude, and altitude.
The rest of the
doubles are the values of each of the calculated values.
If the value cannot be calculated,
it will be set to nan.</p>
<p>Example:</p>
<pre><code>result = testData.madCalculator2(1999,2,15,12,30,0,[45,55],[-170,-150],[200,300],'sdwht,kp')

result = [ [1999.0, 2.0, 15.0, 12.0, 30.0, 0.0, 3.0, 15.0]
           [1999.0, 2.0, 15.0, 12.0, 45.0, 0.0, 3.0, 15.0]
           [1999.0, 2.0, 15.0, 13.0, 0.0, 0.0, 3.0, 15.0]
           [1999.0, 2.0, 15.0, 13.0, 15.0, 0.0, 3.0, 15.0] ]
</code></pre>
<dl>
<dt><code>
Columns</code></dt>
<dd>
<p>gdlat
glon
gdalt
sdwht
kp</p>
</dd>
</dl>
<p>Now uses POST to avoid long url issue</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def madCalculator2(self,
                  year,
                  month,
                  day,
                  hour,
                  min,
                  sec,
                  latList,
                  lonList,
                  altList,
                  parms,
                  oneDParmList=[],
                  oneDParmValues=[],
                  twoDParmList = [],
                  twoDParmValues = []):
    &#34;&#34;&#34;
    madCalculator2 is similar to madCalculator, except that a random collection of points in space can be specified,
    rather than a grid of points.  Also, a user can input 2D data.
    
    Added to Madrigal2.6 as web service - will not run on earlier Madrigal installations.

    Input arguments:

        1. year - int 

        2. month - int 

        3. day - int
        
        4. hour - int 

        5. min - int 

        6. sec - int 

        7. latList - a list of geodetic latitudes, -90 to 90

        8. lonList - a list of longitudes, -180 to 180. Length must = lats
        
        9. altList - a list of geodetic altitudes in km. Length must = lats

        10. parms - comma delimited string of Madrigal parameters desired

        11. oneDParmList - a list of one-D parameters whose values should
                           be set for the calculation.  Can be codes or mnemonics.
                           Defaults to empty list.

        12. oneDParmValues - a list of values (doubles) associated with the one-D
                             parameters specified in oneDParmList. Defaults to empty list.
                             
        13. twoDParmList - a python list of two-D parameters as mnemonics.  Defaults to [].
        
        14. twoDParmValues - a python list of lists of len = len(twoDParmList). Each individual 
                         list is a list of doubles representing values of the two-D
                         parameter set in twoDParmList, with a length = number 
                         of points (or equal to len(lats)). Defaults to [].

    Returns:

        A list of lists of doubles, where each list contains 3 + number of parameters doubles.
        The first three doubles are the input latitude, longitude, and altitude.  The rest of the
        doubles are the values of each of the calculated values.  If the value cannot be calculated,
        it will be set to nan.

        Example:

            result = testData.madCalculator2(1999,2,15,12,30,0,[45,55],[-170,-150],[200,300],&#39;sdwht,kp&#39;)

            result = [ [1999.0, 2.0, 15.0, 12.0, 30.0, 0.0, 3.0, 15.0]
                       [1999.0, 2.0, 15.0, 12.0, 45.0, 0.0, 3.0, 15.0]
                       [1999.0, 2.0, 15.0, 13.0, 0.0, 0.0, 3.0, 15.0]
                       [1999.0, 2.0, 15.0, 13.0, 15.0, 0.0, 3.0, 15.0] ]


            Columns:     gdlat  glon    gdalt  sdwht   kp
            
    Now uses POST to avoid long url issue

&#34;&#34;&#34;

    # verify Madrigal site can call this command
    if self.compareVersions(&#39;2.6&#39;, self._madVers):
        raise IOError(&#39;madCalculator2 requires Madrigal 2.6 or greater, but this site is version %s&#39; % (self._madVers))

    scriptName = &#39;madCalculator2Service.py&#39;
    
    if parms.find(&#39; &#39;) != -1:
        parms = parms.replace(&#39; &#39;, &#39;&#39;) # remove all spaces

    url = self.cgiurl + scriptName
    

    # error checking
    if len(oneDParmList) != len(oneDParmValues):
        raise ValueError(&#39;len(oneDParmList) != len(oneDParmValues)&#39;)
    
    if len(latList) == 0:
        raise ValueError(&#39;length of latList must be at least one&#39;)
    
    if len(latList) != len(lonList) or len(latList) != len(altList):
        raise ValueError(&#39;lengths of latList, lonList, altList must all be equal&#39;)
    
    if len(oneDParmList) != len(oneDParmValues):
        raise ValueError(&#39;len(oneDParmList) != len(oneDParmValues)&#39;)
    
    postUrl = &#39;year&#39;
    # append arguments
    delimiter = &#39;,&#39;
    postUrl += &#39;=%i&amp;month&#39; % (int(year))
    postUrl += &#39;=%i&amp;day&#39; % (int(month))
    postUrl += &#39;=%i&amp;hour&#39; % (int(day))
    postUrl += &#39;=%i&amp;min&#39; % (int(hour))
    postUrl += &#39;=%i&amp;sec&#39; % (int(min))
    postUrl += &#39;=%i&amp;lats=&#39; % (int(sec))
    for i in range(len(latList)):
        postUrl += str(latList[i])
        if i + 1 &lt; len(latList):
            postUrl += &#39;,&#39;
    postUrl += &#39;&amp;longs=&#39;
    for i in range(len(lonList)):
        postUrl += str(lonList[i])
        if i + 1 &lt; len(lonList):
            postUrl += &#39;,&#39;
    postUrl += &#39;&amp;alts=&#39;
    for i in range(len(altList)):
        postUrl += str(altList[i])
        if i + 1 &lt; len(altList):
            postUrl += &#39;,&#39;
    postUrl += &#39;&amp;parms=%s&#39; % (parms)

    for i in range(len(oneDParmList)):
        postUrl += &#39;&amp;oneD=%s,%s&#39; % (str(oneDParmList[i]), str(oneDParmValues[i]))
        
    for i in range(len(twoDParmList)):
        postUrl += &#39;&amp;twoD=%s,&#39; % (str(twoDParmList[i]))
        for j in range(len(twoDParmValues[i])):
            postUrl += str(twoDParmValues[i][j])
            if j + 1 &lt; len(twoDParmValues[i]):
                postUrl += &#39;,&#39;
                
    # remove any pluses in the url due to scientific notation
    postUrl = postUrl.replace(&#39;+&#39;, &#39;%2B&#39;)
        
    data = postUrl.encode(&#34;utf-8&#34;)

    # read main url
    try:
        req = urllib2.Request(url)
        response = urllib2.urlopen(req, data=data, timeout=TIMEOUT)
    except:
        raise ValueError(&#39;unable to open url &#39; + str((url, postUrl)))
            

    page = response.read().decode(&#39;utf8&#39;)
    page = page.split(&#39;\n&#39;)

    response.close()

    # parse the result
    if len(page) == 0:
        raise ValueError(&#39;No data found at url&#39; + str(url))

    # check that error was not returned
    for line in page:
        if line.find(&#39;Error occurred&#39;) != -1:
            raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

    result = []

    # parse output
    for line in page:
        items = line.split()
        if len(items) &lt; 3:
            # blank line
            continue
        newList = []
        for item in items:
            try:
                newList.append(float(item))
            except:
                newList.append(str(item))
        result.append(newList)

    return result</code></pre>
</details>
</dd>
<dt id="madrigalWeb.madrigalWeb.MadrigalData.madCalculator3"><code class="name flex">
<span>def <span class="ident">madCalculator3</span></span>(<span>self, yearList, monthList, dayList, hourList, minList, secList, latList, lonList, altList, parms, oneDParmList=[], oneDParmValues=[], twoDParmList=[], twoDParmValues=[])</span>
</code></dt>
<dd>
<div class="desc"><p>madCalculator3 is similar to madCalculator, except that multiple times can be specified,
where each time can have its own unique spatial positions and 1D and 2D parms. It is
equivalent to multiple calls to madCalculator2, except that it should greatly improve
performance where multiple calls to madCalculator2 are required for different times.
The only restriction is that the same parameters must be requested for every time.</p>
<p>Added to Madrigal2.6 as web service - will not run on earlier Madrigal installations.</p>
<p>Now uses POST to send arguments, due to large volume of data possible</p>
<p>Input arguments:</p>
<pre><code>1. yearList - a list of years, one for each time requested (ints)

2. monthList - a list of months, one for each time requested. (ints)

3. dayList - a list of days, one for each time requested. (ints)

4. hourList - a list of hours, one for each time requested. (ints)

5. minList - a list of minutes, one for each time requested. (ints)

6. secList - a list of seconds, one for each time requested. (ints)

7. latList - a list of lists of geodetic latitudes, -90 to 90.  The
   first list is for the first time, the second for the second time, etc.
   The list do not need to have the same number of points.  The number
   of times must match yearList.
   Data organization: latList[timeIndex][positionIndex]

8. lonList - a list of lists of longitudes, -180 to 180. The
   first list is for the first time, the second for the second time, etc.
   The list do not need to have the same number of points.  The number
   of times must match yearList. Lens must match latList
   Data organization: lonList[timeIndex][positionIndex]

9. altList - a list of lists of geodetic altitudes in km. The
   first list is for the first time, the second for the second time, etc.
   The list do not need to have the same number of points.  The number
   of times must match yearList. Lens must match latList
   Data organization: altList[timeIndex][positionIndex]

10. parms - comma delimited string of Madrigal parameters desired

11. oneDParmList - a list of one-D parameters whose values should
                   be set for the calculation.  Can be codes or mnemonics.
                   Defaults to empty list.

12. oneDParmValues - a list of lists of values (doubles) associated with the one-D
                     parameters specified in oneDParmList. Defaults to empty list.
                     The first list is for the first 1D parameter in oneDParmList,
                     and must be on length len(yearList).  The second list is for 
                     the second parameter, etc. 
                     Data organization: onDParmValues[parameterIndex][timeIndex]

13. twoDParmList - a python list of of two-D parameters as mnemonics.  Defaults to [].

14. twoDParmValues - a list of lists of lists of values (doubles) associated with the two-D
                     parameters specified in twoDParmList. Defaults to empty list.
                     The first list is for the first 2D parameter in oneDParmList,
                     and must be a list of length len(yearList).  Each list in that
                     list must be of len(num positions for that time). The second list is for 
                     the second parameter, etc. 
                     Data organization: twoDParmValues[parameterIndex][timeIndex][positionIndex]
</code></pre>
<h2 id="returns">Returns</h2>
<p>A list of lists of doubles, where each list contains 9 + number of parameters doubles.
The first nine doubles are:
1) year, 2) month, 3) day, 4) hour, 5) minute, 6) second,
7) input latitude, 8) longitude, and 9) altitude.<br>
The rest of the doubles are the values of each of the calculated values.
If the value
cannot be calculated, it will be set to nan.</p>
<p>Example:</p>
<pre><code>testData.madCalculator3(yearList=[2001,2001], monthList=[3,3], dayList=[19,20],
                     hourList=[12,12], minList=[30,40], secList=[20,0],
                     latList=[[45,46,47,48.5],[46,47,48.2,49,50]],
                     lonList=[[-70,-71,-72,-73],[-70,-71,-72,-73,-74]],
                     altList=[[145,200,250,300.5],[200,250,300,350,400]],
                     parms='bmag,pdcon,ne_model',
                     oneDParmList=['kinst','elm'],
                     oneDParmValues=[[31.0,31.0],[45.0,50.0]],
                     twoDParmList=['ti','te','ne'],
                     twoDParmValues=[[[1000,1000,1000,1000],[1000,1000,1000,1000,1000]],
                                     [[1100,1200,1300,1400],[1500,1000,1100,1200,1300]],
                                     [[1.0e10,1.0e10,1.0e10,1.0e10],[1.0e10,1.0e10,1.0e10,1.0e10,1.0e10]]])
</code></pre>
<dl>
<dt><code>
Columns</code></dt>
<dd>
<p>year month day hour minute second gdlat
glon
gdalt
bmag
pdcon
ne_model</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def madCalculator3(self,
                  yearList,
                  monthList,
                  dayList,
                  hourList,
                  minList,
                  secList,
                  latList,
                  lonList,
                  altList,
                  parms,
                  oneDParmList=[],
                  oneDParmValues=[],
                  twoDParmList = [],
                  twoDParmValues = []):
    &#34;&#34;&#34;
    madCalculator3 is similar to madCalculator, except that multiple times can be specified,
    where each time can have its own unique spatial positions and 1D and 2D parms. It is
    equivalent to multiple calls to madCalculator2, except that it should greatly improve 
    performance where multiple calls to madCalculator2 are required for different times.
    The only restriction is that the same parameters must be requested for every time.
    
    Added to Madrigal2.6 as web service - will not run on earlier Madrigal installations.
    
    Now uses POST to send arguments, due to large volume of data possible

    Input arguments:

        1. yearList - a list of years, one for each time requested (ints)

        2. monthList - a list of months, one for each time requested. (ints)

        3. dayList - a list of days, one for each time requested. (ints)
        
        4. hourList - a list of hours, one for each time requested. (ints)

        5. minList - a list of minutes, one for each time requested. (ints)

        6. secList - a list of seconds, one for each time requested. (ints)

        7. latList - a list of lists of geodetic latitudes, -90 to 90.  The
           first list is for the first time, the second for the second time, etc.
           The list do not need to have the same number of points.  The number
           of times must match yearList.
           Data organization: latList[timeIndex][positionIndex]

        8. lonList - a list of lists of longitudes, -180 to 180. The
           first list is for the first time, the second for the second time, etc.
           The list do not need to have the same number of points.  The number
           of times must match yearList. Lens must match latList
           Data organization: lonList[timeIndex][positionIndex]
        
        9. altList - a list of lists of geodetic altitudes in km. The
           first list is for the first time, the second for the second time, etc.
           The list do not need to have the same number of points.  The number
           of times must match yearList. Lens must match latList
           Data organization: altList[timeIndex][positionIndex]

        10. parms - comma delimited string of Madrigal parameters desired

        11. oneDParmList - a list of one-D parameters whose values should
                           be set for the calculation.  Can be codes or mnemonics.
                           Defaults to empty list.

        12. oneDParmValues - a list of lists of values (doubles) associated with the one-D
                             parameters specified in oneDParmList. Defaults to empty list.
                             The first list is for the first 1D parameter in oneDParmList,
                             and must be on length len(yearList).  The second list is for 
                             the second parameter, etc. 
                             Data organization: onDParmValues[parameterIndex][timeIndex]
                             
        13. twoDParmList - a python list of of two-D parameters as mnemonics.  Defaults to [].
        
        14. twoDParmValues - a list of lists of lists of values (doubles) associated with the two-D
                             parameters specified in twoDParmList. Defaults to empty list.
                             The first list is for the first 2D parameter in oneDParmList,
                             and must be a list of length len(yearList).  Each list in that
                             list must be of len(num positions for that time). The second list is for 
                             the second parameter, etc. 
                             Data organization: twoDParmValues[parameterIndex][timeIndex][positionIndex]

    Returns:

        A list of lists of doubles, where each list contains 9 + number of parameters doubles.
        The first nine doubles are:
        1) year, 2) month, 3) day, 4) hour, 5) minute, 6) second,
        7) input latitude, 8) longitude, and 9) altitude.  
        The rest of the doubles are the values of each of the calculated values.  If the value 
        cannot be calculated, it will be set to nan.

        Example:

            testData.madCalculator3(yearList=[2001,2001], monthList=[3,3], dayList=[19,20],
                                 hourList=[12,12], minList=[30,40], secList=[20,0],
                                 latList=[[45,46,47,48.5],[46,47,48.2,49,50]],
                                 lonList=[[-70,-71,-72,-73],[-70,-71,-72,-73,-74]],
                                 altList=[[145,200,250,300.5],[200,250,300,350,400]],
                                 parms=&#39;bmag,pdcon,ne_model&#39;,
                                 oneDParmList=[&#39;kinst&#39;,&#39;elm&#39;],
                                 oneDParmValues=[[31.0,31.0],[45.0,50.0]],
                                 twoDParmList=[&#39;ti&#39;,&#39;te&#39;,&#39;ne&#39;],
                                 twoDParmValues=[[[1000,1000,1000,1000],[1000,1000,1000,1000,1000]],
                                                 [[1100,1200,1300,1400],[1500,1000,1100,1200,1300]],
                                                 [[1.0e10,1.0e10,1.0e10,1.0e10],[1.0e10,1.0e10,1.0e10,1.0e10,1.0e10]]])


            Columns:     year month day hour minute second gdlat  glon  gdalt  bmag  pdcon  ne_model

&#34;&#34;&#34;
    # verify Madrigal site can call this command
    if self.compareVersions(&#39;2.6&#39;, self._madVers):
        raise IOError(&#39;madCalculator3 requires Madrigal 2.6 or greater, but this site is version %s&#39; % (self._madVers))


    scriptName = &#39;madCalculator3Service.py&#39;

    url = self.cgiurl + scriptName
    
    postUrl = &#39;&#39;

    # error checking
    try:
        totalTimes = len(yearList)
    except:
        raise ValueError(&#39;yearList must be a list, not %s&#39; % (str(yearList)))
    
    if len(monthList) != totalTimes or \
       len(dayList) != totalTimes or \
       len(hourList) != totalTimes or \
       len(minList) != totalTimes or \
       len(secList) != totalTimes:
        raise ValueError(&#39;Not all time lists have same length&#39;)
    
    if parms.find(&#39; &#39;) != -1:
        parms = parms.replace(&#39; &#39;, &#39;&#39;) # remove all spaces
    
    # add time arguments
    postUrl += &#39;year=&#39;
    for i, year in enumerate(yearList):
        postUrl += &#39;%i&#39; % (year)
        if i+1 &lt; len(yearList):
            postUrl += &#39;,&#39;
            
    postUrl += &#39;&amp;month=&#39;
    for i, month in enumerate(monthList):
        postUrl += &#39;%i&#39; % (month)
        if i+1 &lt; len(monthList):
            postUrl += &#39;,&#39;
    
    postUrl += &#39;&amp;day=&#39;
    for i, day in enumerate(dayList):
        postUrl += &#39;%i&#39; % (day)
        if i+1 &lt; len(dayList):
            postUrl += &#39;,&#39;
    
    postUrl += &#39;&amp;hour=&#39;
    for i, hour in enumerate(hourList):
        postUrl += &#39;%i&#39; % (hour)
        if i+1 &lt; len(hourList):
            postUrl += &#39;,&#39;
            
    postUrl += &#39;&amp;min=&#39;
    for i, minute in enumerate(minList):
        postUrl += &#39;%i&#39; % (minute)
        if i+1 &lt; len(minList):
            postUrl += &#39;,&#39;
            
    postUrl += &#39;&amp;sec=&#39;
    for i, sec in enumerate(secList):
        postUrl += &#39;%i&#39; % (sec)
        if i+1 &lt; len(secList):
            postUrl += &#39;,&#39;
            
    # get numPos list from latList
    numPos = []
    for lats in latList:
        numPos.append(len(lats))
        
    postUrl += &#39;&amp;numPos=&#39;
    for i, pos in enumerate(numPos):
        postUrl += &#39;%i&#39; % (pos)
        if i+1 &lt; len(numPos):
            postUrl += &#39;,&#39;
            
    postUrl += &#39;&amp;lats=&#39;
    for i, posList in enumerate(latList):
        if len(posList) != numPos[i]:
            raise ValueError(&#39;mismatched number of points in latList&#39;)
        for j, pos in enumerate(posList):
            postUrl += &#39;%f&#39; % (pos)
            if i+1 &lt; len(latList) or j+1 &lt; len(posList):
                postUrl += &#39;,&#39;
                
    postUrl += &#39;&amp;longs=&#39;
    for i, posList in enumerate(lonList):
        if len(posList) != numPos[i]:
            raise ValueError(&#39;mismatched number of points in lonList&#39;)
        for j, pos in enumerate(posList):
            postUrl += &#39;%f&#39; % (pos)
            if i+1 &lt; len(lonList) or j+1 &lt; len(posList):
                postUrl += &#39;,&#39;
                
    postUrl += &#39;&amp;alts=&#39;
    for i, posList in enumerate(altList):
        if len(posList) != numPos[i]:
            raise ValueError(&#39;mismatched number of points in altList&#39;)
        for j, pos in enumerate(posList):
            postUrl += &#39;%f&#39; % (pos)
            if i+1 &lt; len(altList) or j+1 &lt; len(posList):
                postUrl += &#39;,&#39;
                
    postUrl += &#39;&amp;parms=%s&#39; % (parms)
                                                              
    if len(oneDParmList) != len(oneDParmValues):
        raise ValueError(&#39;len(oneDParmList) != len(oneDParmValues)&#39;)

    for i, parm in enumerate(oneDParmList):
        postUrl += &#39;&amp;oneD=%s,&#39; % (str(parm))
        if len(oneDParmValues[i]) != totalTimes:
            raise ValueError(&#39;wrong number of 1D parms for %s&#39; % (str(parm)))
        for j, value in enumerate(oneDParmValues[i]):
            postUrl += &#39;%f&#39; % (value)
            if j+1 &lt; len(oneDParmValues[i]):
                postUrl += &#39;,&#39;
                
    for i, parm in enumerate(twoDParmList):
        postUrl += &#39;&amp;twoD=%s,&#39; % (str(parm))
        if len(twoDParmValues[i]) != totalTimes:
            raise ValueError(&#39;wrong number of 2D parms for %s&#39; % (str(parm)))
        for j, valueList in enumerate(twoDParmValues[i]):
            if len(valueList) != numPos[j]:
                raise ValueError(&#39;wrong number of 2D parms for %s&#39; % (str(parm)))
            for k, value in enumerate(valueList):
                postUrl += &#39;%f&#39; % (value)
                if j+1 &lt; len(twoDParmValues[i]) or k+1 &lt; len(valueList):
                    postUrl += &#39;,&#39;  
                    
    # remove any pluses in the url due to scientific notation
    postUrl = postUrl.replace(&#39;+&#39;, &#39;%2B&#39;)
             
    data = postUrl.encode(&#39;utf8&#39;)

    # read main url
    try:
        req = urllib2.Request(url)
        response = urllib2.urlopen(req, data=data, timeout=TIMEOUT)
    except:
        raise ValueError(&#39;unable to open url &#39; + str((url, postUrl)))
            

    page = response.read().decode(&#39;utf8&#39;)
    page = page.split(&#39;\n&#39;)

    response.close()

    # parse the result
    if len(page) == 0:
        raise ValueError(&#39;No data found at url&#39; + str(url))

    # check that error was not returned
    for line in page:
        if line.find(&#39;Error occurred&#39;) != -1:
            raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

    result = []
    
    # time data to add to each line
    year=None
    month=None
    day=None
    hour=None
    minute=None
    second=None
    
    for line in page:
        items = line.split()
        if len(items) &lt; 3:
            # blank line
            continue
        if line.find(&#39;TIME&#39;) != -1:
            # new time found
            dates=items[1].split(&#39;/&#39;)
            year = int(dates[2])
            month = int(dates[0])
            day = int(dates[1])
            times=items[2].split(&#39;:&#39;)
            hour = int(times[0])
            minute = int(times[1])
            second = int(times[2])
            continue
        newList = [year,month,day,hour,minute,second]
        for item in items:
            try:
                newList.append(float(item))
            except:
                newList.append(str(item))
        result.append(newList)

    return result</code></pre>
</details>
</dd>
<dt id="madrigalWeb.madrigalWeb.MadrigalData.madTimeCalculator"><code class="name flex">
<span>def <span class="ident">madTimeCalculator</span></span>(<span>self, startyear, startmonth, startday, starthour, startmin, startsec, endyear, endmonth, endday, endhour, endmin, endsec, stephours, parms)</span>
</code></dt>
<dd>
<div class="desc"><p>Input arguments:</p>
<pre><code>1. startyear - int

2. startmonth - int

3. startday - int

4. starthour - int

5. startmin - int

6. startsec - int

7. endyear - int

8. endmonth - int

9. endday - int

10. endhour - int

11. endmin - int

12. endsec - int

13. stephours - float - number of hours per time step

14. parms - comma delimited string of Madrigal parameters desired (must not depend on location)
</code></pre>
<h2 id="returns">Returns</h2>
<p>A list of lists, where each list contains 6 ints (year, month, day, hour, min, sec)
+ number
of parameters.
If the value cannot be calculated, it will be set to nan.</p>
<p>Example:</p>
<pre><code>result = testData.madTestCalculator(1999,2,15,12,30,0,
                                    1999,2,20,12,30,0,
                                    24.0, 'kp,dst')

result = [[1999.0, 2.0, 15.0, 12.0, 30.0, 0.0, 3.0, -9.0]
          [1999.0, 2.0, 16.0, 12.0, 30.0, 0.0, 1.0, -6.0]
          [1999.0, 2.0, 17.0, 12.0, 30.0, 0.0, 4.0, -31.0]
          [1999.0, 2.0, 18.0, 12.0, 30.0, 0.0, 6.7000000000000002, -93.0]
          [1999.0, 2.0, 19.0, 12.0, 30.0, 0.0, 5.2999999999999998, -75.0]]
</code></pre>
<dl>
<dt><code>
Columns</code></dt>
<dd>
<p>year, month, day, hour, min, sec, kp, dst</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def madTimeCalculator(self,
                      startyear,
                      startmonth,
                      startday,
                      starthour,
                      startmin,
                      startsec,
                      endyear,
                      endmonth,
                      endday,
                      endhour,
                      endmin,
                      endsec,
                      stephours,
                      parms):
    &#34;&#34;&#34;

    Input arguments:

        1. startyear - int 

        2. startmonth - int 

        3. startday - int
        
        4. starthour - int 

        5. startmin - int 

        6. startsec - int

        7. endyear - int 

        8. endmonth - int 

        9. endday - int
        
        10. endhour - int 

        11. endmin - int 

        12. endsec - int

        13. stephours - float - number of hours per time step

        14. parms - comma delimited string of Madrigal parameters desired (must not depend on location)

    Returns:

        A list of lists, where each list contains 6 ints (year, month, day, hour, min, sec)  + number
        of parameters.  If the value cannot be calculated, it will be set to nan.

        Example:

            result = testData.madTestCalculator(1999,2,15,12,30,0,
                                                1999,2,20,12,30,0,
                                                24.0, &#39;kp,dst&#39;)

            result = [[1999.0, 2.0, 15.0, 12.0, 30.0, 0.0, 3.0, -9.0]
                      [1999.0, 2.0, 16.0, 12.0, 30.0, 0.0, 1.0, -6.0]
                      [1999.0, 2.0, 17.0, 12.0, 30.0, 0.0, 4.0, -31.0]
                      [1999.0, 2.0, 18.0, 12.0, 30.0, 0.0, 6.7000000000000002, -93.0]
                      [1999.0, 2.0, 19.0, 12.0, 30.0, 0.0, 5.2999999999999998, -75.0]]

            Columns:     year, month, day, hour, min, sec, kp, dst

    &#34;&#34;&#34;

    scriptName = &#39;madTimeCalculatorService.py&#39;

    url = self.cgiurl + scriptName + &#39;?startyear&#39;
    
    if parms.find(&#39; &#39;) != -1:
        parms = parms.replace(&#39; &#39;, &#39;&#39;) # remove all spaces

    # append arguments
    url += &#39;=%i&amp;startmonth&#39; % (int(startyear))
    url += &#39;=%i&amp;startday&#39; % (int(startmonth))
    url += &#39;=%i&amp;starthour&#39; % (int(startday))
    url += &#39;=%i&amp;startmin&#39; % (int(starthour))
    url += &#39;=%i&amp;startsec&#39; % (int(startmin))
    url += &#39;=%i&amp;endyear&#39; % (int(startsec))
    url += &#39;=%i&amp;endmonth&#39; % (int(endyear))
    url += &#39;=%i&amp;endday&#39; % (int(endmonth))
    url += &#39;=%i&amp;endhour&#39; % (int(endday))
    url += &#39;=%i&amp;endmin&#39; % (int(endhour))
    url += &#39;=%i&amp;endsec&#39; % (int(endmin))
    url += &#39;=%i&amp;stephours&#39; % (int(endsec))
    url += &#39;=%f&amp;parms&#39; % (float(stephours))
    url += &#39;=%s&#39; % (parms)
    
    # remove any pluses in the url due to scientific notation
    url = url.replace(&#39;+&#39;, &#39;%2B&#39;)

    # read main url
    try:
        mainUrl = urllib2.urlopen(url, timeout=TIMEOUT)
    except:
        raise ValueError(&#39;unable to open url &#39; + str(url))
            

    page = mainUrl.read().decode(&#39;utf8&#39;)
    page = page.split(&#39;\n&#39;)

    mainUrl.close()

    # parse the result
    if len(page) == 0:
        raise ValueError(&#39;No data found at url&#39; + str(url))

    # check that error was not returned
    for line in page:
        if line.find(&#39;Error occurred&#39;) != -1:
            raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

    result = []

    # parse output
    for line in page:
        items = line.split()
        if len(items) &lt; 3:
            # blank line
            continue
        newList = []
        for item in items:
            try:
                newList.append(float(item))
            except:
                newList.append(str(item))
        result.append(newList)

    return result</code></pre>
</details>
</dd>
<dt id="madrigalWeb.madrigalWeb.MadrigalData.radarToGeodetic"><code class="name flex">
<span>def <span class="ident">radarToGeodetic</span></span>(<span>self, slatgd, slon, saltgd, az, el, radarRange)</span>
</code></dt>
<dd>
<div class="desc"><p>radarToGeodetic converts arrays of az, el, and ranges to geodetic locations.</p>
<p>Input arguments:</p>
<pre><code>1. slatgd - radar geodetic latitude

2. slon - radar longitude

3. saltgd - radar altitude

4. az - either a single azimuth, or a list of azimuths

5. el - either a single elevation, or a list of elevations.  If so, len(el)
        must = len(az)

6. radarRange - either a single range, or a list of ranges.  If so, len(radarRange)
                must = len(az)
</code></pre>
<h2 id="returns">Returns</h2>
<p>A list of lists, where each list contains 3 floats (gdlat, glon, and gdalt)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def radarToGeodetic(self,
                    slatgd,
                    slon,
                    saltgd,
                    az,
                    el,
                    radarRange):
    &#34;&#34;&#34;radarToGeodetic converts arrays of az, el, and ranges to geodetic locations.

    Input arguments:

        1. slatgd - radar geodetic latitude 

        2. slon - radar longitude 

        3. saltgd - radar altitude
        
        4. az - either a single azimuth, or a list of azimuths 

        5. el - either a single elevation, or a list of elevations.  If so, len(el)
                must = len(az)

        6. radarRange - either a single range, or a list of ranges.  If so, len(radarRange)
                        must = len(az)


    Returns:

        A list of lists, where each list contains 3 floats (gdlat, glon, and gdalt)
    &#34;&#34;&#34;
    scriptName = &#39;radarToGeodeticService.py&#39;

    url = self.cgiurl + scriptName + &#39;?slatgd&#39;

    # append arguments
    url += &#39;=%f&amp;slon&#39; % (float(slatgd))
    url += &#39;=%f&amp;saltgd&#39; % (float(slon))
    url += &#39;=%f&amp;&#39; % (float(saltgd))

    if type(az) == list or type(az) == tuple:
        if len(az) != len(el) or len(az) != len(radarRange):
            raise ValueError(&#39;all lists most have same length&#39;)
        for i in range(len(az)):
            if i == 0:
                arg = str(az[i])
            else:
                arg += &#39;,&#39; + str(az[i])
        url += &#39;az=%s&amp;&#39; % (arg)

        for i in range(len(el)):
            if i == 0:
                arg = str(el[i])
            else:
                arg += &#39;,&#39; + str(el[i])
        url += &#39;el=%s&amp;&#39; % (arg)

        for i in range(len(radarRange)):
            if i == 0:
                arg = str(radarRange[i])
            else:
                arg += &#39;,&#39; + str(radarRange[i])
        url += &#39;range=%s&#39; % (arg)

    else:
        url += &#39;az=%f&amp;&#39; % (az)
        url += &#39;el=%f&amp;&#39; % (el)
        url += &#39;range=%f&amp;&#39; % (radarRange)
        
    # remove any pluses in the url due to scientific notation
    url = url.replace(&#39;+&#39;, &#39;%2B&#39;)

    # read main url
    try:
        mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
    except:
        raise ValueError(&#39;unable to open url &#39; + str(url))
            
    page = mainUrl.read().decode(&#39;utf8&#39;)
    page = page.split(&#39;\n&#39;)

    mainUrl.close()

    # parse the result
    if len(page) == 0:
        raise ValueError(&#39;No data found at url&#39; + str(url))

    # check that error was not returned
    for line in page:
        if line.find(&#39;Error occurred&#39;) != -1:
            raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

    result = []

    # parse output
    for line in page:
        items = line.split(&#39;,&#39;)
        if len(items) &lt; 3:
            # blank line
            continue
        newList = []
        for item in items:
            try:
                newList.append(float(item))
            except:
                newList.append(str(item))
        result.append(newList)

    return result</code></pre>
</details>
</dd>
<dt id="madrigalWeb.madrigalWeb.MadrigalData.simplePrint"><code class="name flex">
<span>def <span class="ident">simplePrint</span></span>(<span>self, filename, user_fullname, user_email, user_affiliation)</span>
</code></dt>
<dd>
<div class="desc"><p>simplePrint prints the data in the given file is a simple ascii format.</p>
<p>simplePrint prints only the parameters in the file, without filters or derived
parameters.
To choose which parameters to print, to print derived parameters, or
to filter the data, use isprint instead.</p>
<h2 id="inputs">Inputs</h2>
<p>filename - The absolute filename to be printed.
Returned by getExperimentFiles.</p>
<p>user_fullname - full name of user making request</p>
<p>user_email - email address of user making request</p>
<p>user_affiliation - affiliation of user making request</p>
<p>Returns: string representing all data in the file in ascii, space-delimited form.
The first line if the list of parameters printed.
The first six parameters will
always be year, month, day, hour, min, sec, representing the middle time of
the measurment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplePrint(self, filename, user_fullname, user_email, user_affiliation):
    &#34;&#34;&#34;simplePrint prints the data in the given file is a simple ascii format.

    simplePrint prints only the parameters in the file, without filters or derived
    parameters.  To choose which parameters to print, to print derived parameters, or
    to filter the data, use isprint instead.

    Inputs:

        filename - The absolute filename to be printed.  Returned by getExperimentFiles.

        user_fullname - full name of user making request

        user_email - email address of user making request

        user_affiliation - affiliation of user making request

    Returns: string representing all data in the file in ascii, space-delimited form.
             The first line if the list of parameters printed.  The first six parameters will
             always be year, month, day, hour, min, sec, representing the middle time of
             the measurment.
    &#34;&#34;&#34;
    parms = self.getExperimentFileParameters(filename)

    parmStr = &#39;year,month,day,hour,min,sec&#39;
    labelStr = &#39;YEAR     MONTH       DAY      HOUR       MIN       SEC        &#39;

    for parm in parms:
        if parm.isMeasured and parm.isAddIncrement != 1:
            parmStr += &#39;,%s&#39; % (parm.mnemonic)
            thisLabel = parm.mnemonic[:11].upper()
            labelStr += &#39;%s%s&#39; % (thisLabel, &#39; &#39;*(11-len(thisLabel)))

    retStr = &#39;%s\n&#39; % (labelStr)

    retStr += self.isprint(filename, parmStr, &#39;&#39;, user_fullname, user_email, user_affiliation)

    return(retStr)</code></pre>
</details>
</dd>
<dt id="madrigalWeb.madrigalWeb.MadrigalData.traceMagneticField"><code class="name flex">
<span>def <span class="ident">traceMagneticField</span></span>(<span>self, year, month, day, hour, minute, second, inputType, outputType, alts, lats, lons, model, qualifier, stopAlt=None)</span>
</code></dt>
<dd>
<div class="desc"><p>traceMagneticField returns a point along a magnetic field line for each
point specified by the lists alts, lats, lons.
Traces to either 1) conjugate point, 2) intersection with a given altitude in the
northern or southern hemisphere, 3) to the apex, or 4) to GSM XY plane, depending on qualifier
argument.
Uses Tsyganenko or IGRF fields, depending on model argument.
Input arguments are either GSM or Geodetic, depending on inputType argument.
Output arguments are either GSM or Geodetic, depending on outputType
argument.</p>
<h2 id="inputs">Inputs</h2>
<p>year, month, day, hour, minute, second - time at which to do the trace</p>
<p>inputType
- 0 for geodetic, 1 for GSM</p>
<p>outputType - 0 for geodetic, 1 for GSM</p>
<p>The following parameter depend on inputType:</p>
<p>alts - a list of geodetic altitudes or ZGSMs of starting point</p>
<p>lats - a clist of geodetic latitudes or XGSMs of starting point</p>
<p>lons - a list of longitude or YGSM of starting point</p>
<p>Length of all three lists must be the same</p>
<p>model - 0 for Tsyganenko, 1 for IGRF</p>
<p>qualifier - 0 for conjugate, 1 for north_alt, 2 for south_alt, 3 for apex, 4 for GSM XY plane</p>
<p>stopAlt - altitude in km to stop trace at, if qualifier is north_alt or south_alt.
If other qualifier, this parameter is not required. Default is None, which will raise
exception if qualifier is north_alt or south_alt</p>
<p>Returns a tuple of tuples, one tuple for point in (alts, lats, lons) lists, where each tuple has
three items:</p>
<pre><code>1. geodetic altitude or ZGSM of ending point

2. geodetic latitude or XGSM of ending point

3. longitude or YGSM of ending point
</code></pre>
<p>If error, traceback includes error description</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def traceMagneticField(self, year, month, day, hour, minute,second,
                       inputType, outputType, alts, lats, lons,
                       model, qualifier, stopAlt=None):
    &#34;&#34;&#34;
    traceMagneticField returns a point along a magnetic field line for each
    point specified by the lists alts, lats, lons.
    Traces to either 1) conjugate point, 2) intersection with a given altitude in the
    northern or southern hemisphere, 3) to the apex, or 4) to GSM XY plane, depending on qualifier
    argument.  Uses Tsyganenko or IGRF fields, depending on model argument.
    Input arguments are either GSM or Geodetic, depending on inputType argument.
    Output arguments are either GSM or Geodetic, depending on outputType
    argument.

    Inputs:
    
        year, month, day, hour, minute, second - time at which to do the trace

        inputType  - 0 for geodetic, 1 for GSM

        outputType - 0 for geodetic, 1 for GSM
    
        The following parameter depend on inputType:
        
        alts - a list of geodetic altitudes or ZGSMs of starting point
    
        lats - a clist of geodetic latitudes or XGSMs of starting point
    
        lons - a list of longitude or YGSM of starting point

        Length of all three lists must be the same
    
        model - 0 for Tsyganenko, 1 for IGRF
    
        qualifier - 0 for conjugate, 1 for north_alt, 2 for south_alt, 3 for apex, 4 for GSM XY plane
    
        stopAlt - altitude in km to stop trace at, if qualifier is north_alt or south_alt.
            If other qualifier, this parameter is not required. Default is None, which will raise
            exception if qualifier is north_alt or south_alt

    Returns a tuple of tuples, one tuple for point in (alts, lats, lons) lists, where each tuple has
    three items:

        1. geodetic altitude or ZGSM of ending point

        2. geodetic latitude or XGSM of ending point

        3. longitude or YGSM of ending point


    If error, traceback includes error description
    &#34;&#34;&#34;
    scriptName = &#39;traceMagneticFieldService.py&#39;

    url = self.cgiurl + scriptName + &#39;?&#39;
    
    delimiter = &#39;,&#39;

    # append arguments
    url += &#39;year=%i&amp;&#39; % (int(year))
    url += &#39;month=%i&amp;&#39; % (int(month))
    url += &#39;day=%i&amp;&#39; % (int(day))
    url += &#39;hour=%i&amp;&#39; % (int(hour))
    url += &#39;min=%i&amp;&#39; % (int(minute))
    url += &#39;sec=%i&amp;&#39; % (int(second))
    url += &#39;inputType=%i&amp;&#39; % (int(inputType))
    url += &#39;outputType=%i&amp;&#39; % (int(outputType))
    in1Str = delimiter.join([str(item) for item in alts])
    url += &#39;in1=%s&amp;&#39; % (in1Str)
    in2Str = delimiter.join([str(item) for item in lats])
    url += &#39;in2=%s&amp;&#39; % (in2Str)
    in3Str = delimiter.join([str(item) for item in lons])
    url += &#39;in3=%s&amp;&#39; % (in3Str)
    url += &#39;model=%i&amp;&#39; % (int(model))
    url += &#39;qualifier=%i&amp;&#39; % (int(qualifier))
    if stopAlt == None:
        if int(qualifier) in (1,2):
            raise ValueError(&#39;stopAlt must be set for qualifer in (1,2)&#39;)
        else:
            stopAlt = 0.0
    url += &#39;stopAlt=%s&#39; % (str(stopAlt))
    
    # remove any pluses in the url due to scientific notation
    url = url.replace(&#39;+&#39;, &#39;%2B&#39;)

    # read main url
    try:
        mainUrl = urllib2.urlopen(url, timeout=TIMEOUT2)
    except:
        raise ValueError(&#39;unable to open url &#39; + str(url))

    page = mainUrl.read().decode(&#39;utf8&#39;)
    page = page.split(&#39;\n&#39;)

    mainUrl.close()

    # parse the result
    if len(page) == 0:
        raise ValueError(&#39;No data found at url&#39; + str(url))

    # check that html was not returned
    for line in page:
        if line.find(&#39;Error occurred&#39;) != -1:
            raise ValueError(&#39;error raised using url &#39; + str(url) + &#39; &#39; + str(page))

    result = []
    
    for line in page:
        items = line.split(&#39;,&#39;)
        if len(items) &lt; 3:
            continue
        result.append((float(items[0]),
                       float(items[1]),
                       float(items[2])))

    return result</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="madrigalWeb.madrigalWeb.MadrigalExperiment"><code class="flex name class">
<span>class <span class="ident">MadrigalExperiment</span></span>
<span>(</span><span>id, url, name, siteid, sitename, instcode, instname, startyear, startmonth, startday, starthour, startmin, startsec, endyear, endmonth, endday, endhour, endmin, endsec, isLocal, madrigalUrl, pi, piEmail, uttimestamp, access, version)</span>
</code></dt>
<dd>
<div class="desc"><p>MadrigalExperiment is a class that encapsulates information about a Madrigal Experiment.</p>
<p>Attributes::</p>
<pre><code>id (int) Example: 10000111.  Uniquely identifies experiment.

realUrl (string) the real url to display this experiment in a web browser.

url (string) Example: 'http://madrigal.haystack.mit.edu/cgi-bin/madtoc/1997/mlh/03dec97'
    Note: this is a an old url that no longer works, but it is the form stored in the metadata.
    See realUrl attribute for working url.

name (string) Example: 'Wide Latitude Substorm Study'

siteid (int) Example: 1

sitename (string) Example: 'Millstone Hill Observatory'

instcode (int) Code of instrument. Example: 30

instname (string) Instrument name. Example: 'Millstone Hill Incoherent Scatter Radar'

startyear - int

startmonth - int

startday - int

starthour - int

startmin - int

startsec - int

endyear - int

endmonth - int

endday - int

endhour - int

endmin - int

endsec - int

isLocal - True if a local experiment, False if not

madrigalUrl - url of Madrigal site.  Used if not a local experiment.

pi - experiment Principal investigator

piEmail - experiment Principal investigator's email

realUrl - working url to experiment (use this instead of url)

uttimestamp - st_mtime of expDir. None if not supported by the Madrigal site

access - access code of the experiment (0 if public, 2 if public).  None if not
    supported by the Madrigal site.

version - version of Madrigal site where data located in form I.I[.I] where I is an integer
</code></pre>
<p>Non-standard Python modules used: None</p>
<p>Change history:</p>
<p>Written by "Bill Rideout":mailto:wrideout@haystack.mit.edu
Feb. 10, 2004</p>
<p><strong>init</strong> initializes a MadrigalExperiment.</p>
<p>Inputs::</p>
<pre><code>id (int, or string that can be converted) Example: 10000111.  Uniquely identifies experiment.

url (string) Example: 'http://madrigal.haystack.mit.edu/cgi-bin/madtoc/1997/mlh/03dec97' - see 
    realUrl attribute for an actual url that works in the web

name (string) Example: 'Wide Latitude Substorm Study'

siteid (int, or string that can be converted) Example: 1

sitename (string) Example: 'Millstone Hill Observatory'

instcode (int, or string that can be converted) Code of instrument. Example: 30

instname (string) Instrument name. Example: 'Millstone Hill Incoherent Scatter Radar'

startyear - int, or string that can be converted

startmonth - int, or string that can be converted

startday - int, or string that can be converted

starthour - int, or string that can be converted

startmin - int, or string that can be converted

startsec - int, or string that can be converted

endyear - int, or string that can be converted

endmonth - int, or string that can be converted

endday - int, or string that can be converted

endhour - int, or string that can be converted

endmin - int, or string that can be converted

endsec - int, or string that can be converted

isLocal - True if a local experiment, False if not

madrigalUrl - url of Madrigal site.  Used if not a local experiment.

pi - experiment PI

piEmail - experiment PI email

uttimestamp - st_mtime of expDir. None if not supported by the Madrigal site

access - access code of the experiment (0 if public, 2 if public).  None if not
    supported by the Madrigal site.

version - version of Madrigal site where data located in form I.I[.I] where I is an integer
</code></pre>
<p>Returns: void</p>
<p>Affects: Initializes all the class member variables.</p>
<p>Exceptions: If illegal argument passed in.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MadrigalExperiment:
    &#34;&#34;&#34;MadrigalExperiment is a class that encapsulates information about a Madrigal Experiment.


    Attributes::

        id (int) Example: 10000111.  Uniquely identifies experiment.
        
        realUrl (string) the real url to display this experiment in a web browser.
        
        url (string) Example: &#39;http://madrigal.haystack.mit.edu/cgi-bin/madtoc/1997/mlh/03dec97&#39;
            Note: this is a an old url that no longer works, but it is the form stored in the metadata.
            See realUrl attribute for working url.
        
        name (string) Example: &#39;Wide Latitude Substorm Study&#39;
        
        siteid (int) Example: 1
        
        sitename (string) Example: &#39;Millstone Hill Observatory&#39;
        
        instcode (int) Code of instrument. Example: 30
        
        instname (string) Instrument name. Example: &#39;Millstone Hill Incoherent Scatter Radar&#39;
        
        startyear - int
           
        startmonth - int
       
        startday - int
       
        starthour - int
       
        startmin - int
       
        startsec - int
       
        endyear - int
       
        endmonth - int
       
        endday - int
       
        endhour - int
       
        endmin - int
       
        endsec - int

        isLocal - True if a local experiment, False if not

        madrigalUrl - url of Madrigal site.  Used if not a local experiment.
        
        pi - experiment Principal investigator
        
        piEmail - experiment Principal investigator&#39;s email
        
        realUrl - working url to experiment (use this instead of url)
            
        uttimestamp - st_mtime of expDir. None if not supported by the Madrigal site
        
        access - access code of the experiment (0 if public, 2 if public).  None if not
            supported by the Madrigal site.
            
        version - version of Madrigal site where data located in form I.I[.I] where I is an integer
            
    Non-standard Python modules used: None


    Change history:

    Written by &#34;Bill Rideout&#34;:mailto:wrideout@haystack.mit.edu  Feb. 10, 2004

    &#34;&#34;&#34;
    def __init__(self,
                 id,
                 url,
                 name,
                 siteid,
                 sitename,
                 instcode,
                 instname,
                 startyear,
                 startmonth,
                 startday,
                 starthour,
                 startmin,
                 startsec,
                 endyear,
                 endmonth,
                 endday,
                 endhour,
                 endmin,
                 endsec,
                 isLocal,
                 madrigalUrl,
                 pi,
                 piEmail,
                 uttimestamp,
                 access,
                 version):
        &#34;&#34;&#34;__init__ initializes a MadrigalExperiment.

        Inputs::

            id (int, or string that can be converted) Example: 10000111.  Uniquely identifies experiment.
        
            url (string) Example: &#39;http://madrigal.haystack.mit.edu/cgi-bin/madtoc/1997/mlh/03dec97&#39; - see 
                realUrl attribute for an actual url that works in the web
            
            name (string) Example: &#39;Wide Latitude Substorm Study&#39;
            
            siteid (int, or string that can be converted) Example: 1
            
            sitename (string) Example: &#39;Millstone Hill Observatory&#39;
            
            instcode (int, or string that can be converted) Code of instrument. Example: 30
            
            instname (string) Instrument name. Example: &#39;Millstone Hill Incoherent Scatter Radar&#39;

            startyear - int, or string that can be converted
           
            startmonth - int, or string that can be converted
       
            startday - int, or string that can be converted
       
            starthour - int, or string that can be converted
       
            startmin - int, or string that can be converted
       
            startsec - int, or string that can be converted
       
            endyear - int, or string that can be converted
       
            endmonth - int, or string that can be converted
       
            endday - int, or string that can be converted
       
            endhour - int, or string that can be converted
       
            endmin - int, or string that can be converted
       
            endsec - int, or string that can be converted
            
            isLocal - True if a local experiment, False if not

            madrigalUrl - url of Madrigal site.  Used if not a local experiment.
            
            pi - experiment PI
            
            piEmail - experiment PI email
            
            uttimestamp - st_mtime of expDir. None if not supported by the Madrigal site
        
            access - access code of the experiment (0 if public, 2 if public).  None if not
                supported by the Madrigal site.
                
            version - version of Madrigal site where data located in form I.I[.I] where I is an integer

        Returns: void

        Affects: Initializes all the class member variables.

        Exceptions: If illegal argument passed in.
        &#34;&#34;&#34;

        self.id = int(id)

        if not isStringType(url):
            raise ValueError(&#39;In MadrigalExperiment, url not string type: %s&#39; % (str(url)))

        self.url = url

        if not isStringType(name):
            raise ValueError(&#39;In MadrigalExperiment, name not string type: %s&#39; % (str(name)))

        self.name = name

        self.siteid = int(siteid)

        if not isStringType(sitename):
            raise ValueError(&#39;In MadrigalExperiment, sitename not string type: %s&#39; % (str(sitename)))

        self.sitename = sitename

        self.instcode = int(instcode)

        if not isStringType(instname):
            raise ValueError(&#39;In MadrigalExperiment, instname not string type: %s&#39; % (str(instname)))

        self.instname = instname

        self.startyear = int(startyear)

        self.startmonth = int(startmonth)

        self.startday = int(startday)

        self.starthour = int(starthour)

        self.startmin = int(startmin)

        self.startsec = int(startsec)

        self.endyear = int(endyear)

        self.endmonth = int(endmonth)

        self.endday = int(endday)

        self.endhour = int(endhour)

        self.endmin = int(endmin)

        self.endsec = int(endsec)

        if isLocal not in (True, False):
            raise ValueError(&#39;In MadrigalExperiment, isLocal not boolean: %s&#39; % (str(isLocal)))

        self.isLocal = isLocal

        if not isStringType(madrigalUrl):
            raise ValueError(&#39;In MadrigalExperiment, madrigalUrl not string type: %s&#39; % (str(madrigalUrl)))

        self.madrigalUrl = madrigalUrl
        
        if not isStringType(pi):
            raise ValueError(&#39;In MadrigalExperiment, pi not string type: %s&#39; % (str(pi)))

        self.pi = pi
        
        if not isStringType(piEmail):
            raise ValueError(&#39;In MadrigalExperiment, piEmail not string type: %s&#39; % (str(piEmail)))
                
        self.piEmail = piEmail
        
        if self.isLocal:
            self.realUrl = self._getRealExperimentUrl(version)
        else:
            self.realUrl = &#39;Cannot_get_real_url_for_remote_site&#39;
        
        self.uttimestamp = uttimestamp
        
        self.access = access     
        
        if not isStringType(version):
            raise ValueError(&#39;In MadrigalExperiment, version not string type: %s&#39; % (str(version)))
        self.version = version   
        

        
    def _getRealExperimentUrl(self, version):
        &#34;&#34;&#34;getRealExperimentUrl is a private method that returns the url used in a web browser to see 
        this experiment&#39;s page in full data access interface. Uses to create attribute realUrl.
        
        Inputs:
            version - version of Madrigal site where data located in form I.I[.I] where I is an integer
            
        real url depends on Madrigal version
        &#34;&#34;&#34;
        version_list = [int(item) for item in version.split(&#39;.&#39;)]
        retStr = &#39;&#39;
        index = self.url.find(&#39;/madtoc/&#39;)
        if version_list[0] == 2:
            retStr += self.url[:index] + &#39;/madExperiment.cgi?exp=&#39;
            retStr += self.url[index+8:] + &#39;&amp;displayLevel=0&amp;expTitle=&#39;
            try:
                retStr += urlparse.quote_plus(self.name) # python3
            except AttributeError:
                retStr += urllib.quote_plus(self.name.encode(&#39;utf8&#39;)) # python2
        else:
            retStr += self.url[:index] + &#39;/showExperiment/?experiment_list=%i&#39; % (self.id)
        return(retStr)
        

    def __str__(self):
        &#34;&#34;&#34;return a readible form of this object&#34;&#34;&#34;
        retStr = &#39;&#39;
        retStr += &#39;id: %s\n&#39; % (str(self.id))
        retStr += &#39;realUrl: %s\n&#39; % (self.realUrl)
        retStr += &#39;url: %s\n&#39; % (self.url)
        retStr += &#39;name: %s\n&#39; % (self.name)
        retStr += &#39;siteid: %s\n&#39; % (str(self.siteid))
        retStr += &#39;sitename: %s\n&#39; % (self.sitename)
        retStr += &#39;instcode: %s\n&#39;%  (str(self.instcode))
        retStr += &#39;instname: %s\n&#39; % (self.instname)
        retStr += &#39;startyear: %s\n&#39; % (str(self.startyear))
        retStr += &#39;startmonth: %s\n&#39;%  (str(self.startmonth))
        retStr += &#39;startday: %s\n&#39; % (str(self.startday))
        retStr += &#39;starthour: %s\n&#39;%  (str(self.starthour))
        retStr += &#39;startmin: %s\n&#39; % (str(self.startmin))
        retStr += &#39;startsec: %s\n&#39;%  (str(self.startsec))
        retStr += &#39;endyear: %s\n&#39; % (str(self.endyear))
        retStr += &#39;endmonth: %s\n&#39;%  (str(self.endmonth))
        retStr += &#39;endday: %s\n&#39; % (str(self.endday))
        retStr += &#39;endhour: %s\n&#39;%  (str(self.endhour))
        retStr += &#39;endmin: %s\n&#39; % (str(self.endmin))
        retStr += &#39;endsec: %s\n&#39;%  (str(self.endsec))
        retStr += &#39;isLocal: %s\n&#39; % (str(self.isLocal))
        retStr += &#39;madrigalUrl: %s\n&#39;%  (self.madrigalUrl)
        retStr += &#39;PI: %s\n&#39;%  (self.pi)
        retStr += &#39;PIEmail: %s\n&#39;%  (self.piEmail)
        retStr += &#39;uttimestamp: %s\n&#39;%  (str(self.uttimestamp))
        retStr += &#39;access: %s\n&#39;%  (str(self.access))
        retStr += &#39;Madrigal version: %s\n&#39;%  (self. version)
        return retStr

    def __cmp__(self, other):
        &#34;&#34;&#34; __cmp__ compares two MadrigalExperiment objects.

        Compared by start time, then by end time.
        &#34;&#34;&#34;
        dt1 = datetime.datetime(self.startyear, self.startmonth, self.startday,
                                self.starthour, self.startmin, self.startsec)
        dt2 = datetime.datetime(other.startyear, other.startmonth, other.startday,
                                other.starthour, other.startmin, other.startsec)
        result = cmp(dt1, dt2)
        if result != 0:
            return(result)

        
        dt1 = datetime.datetime(self.endyear, self.endmonth, self.endday,
                                self.endhour, self.endmin, self.endsec)
        dt2 = datetime.datetime(other.endyear, other.endmonth, other.endday,
                                other.endhour, other.endmin, other.endsec)
        return(cmp(dt1, dt2))     
    
    
    def __eq__(self, other):
        &#34;&#34;&#34; __eq__ compares two MadrigalExperiment objects for equality.

        Compared by start time and end time.
        &#34;&#34;&#34;
        dt1s = datetime.datetime(self.startyear, self.startmonth, self.startday,
                                self.starthour, self.startmin, self.startsec)
        dt2s = datetime.datetime(other.startyear, other.startmonth, other.startday,
                                other.starthour, other.startmin, other.startsec)

        
        dt1e = datetime.datetime(self.endyear, self.endmonth, self.endday,
                                self.endhour, self.endmin, self.endsec)
        dt2e = datetime.datetime(other.endyear, other.endmonth, other.endday,
                                other.endhour, other.endmin, other.endsec)
        return(dt1s == dt2s and dt1e == dt2e)                   
        
    def __ne__(self, other):
        &#34;&#34;&#34; __ne__ compares two MadrigalExperiment objects for inequality.

        Simply the inverse of __eq__
        &#34;&#34;&#34;
        return(not(self.__eq__(self, other)))
    
    
    def __lt__(self, other):
        &#34;&#34;&#34; __lt__ compares two MadrigalExperiment objects.

        Compared by start time only
        &#34;&#34;&#34;
        dt1 = datetime.datetime(self.startyear, self.startmonth, self.startday,
                                self.starthour, self.startmin, self.startsec)
        dt2 = datetime.datetime(other.startyear, other.startmonth, other.startday,
                                other.starthour, other.startmin, other.startsec)
        return (dt1 &lt; dt2)
    
    def __le__(self, other):
        &#34;&#34;&#34; __le__ compares two MadrigalExperiment objects.

        Compared by start time only
        &#34;&#34;&#34;
        dt1 = datetime.datetime(self.startyear, self.startmonth, self.startday,
                                self.starthour, self.startmin, self.startsec)
        dt2 = datetime.datetime(other.startyear, other.startmonth, other.startday,
                                other.starthour, other.startmin, other.startsec)
        return (dt1 &lt;= dt2)
    
    def __gt__(self, other):
        &#34;&#34;&#34; __gt__ compares two MadrigalExperiment objects.

        Compared by start time only
        &#34;&#34;&#34;
        dt1 = datetime.datetime(self.startyear, self.startmonth, self.startday,
                                self.starthour, self.startmin, self.startsec)
        dt2 = datetime.datetime(other.startyear, other.startmonth, other.startday,
                                other.starthour, other.startmin, other.startsec)
        return (dt1 &gt; dt2)
    
    def __ge__(self, other):
        &#34;&#34;&#34; __ge__ compares two MadrigalExperiment objects.

        Compared by start time only
        &#34;&#34;&#34;
        dt1 = datetime.datetime(self.startyear, self.startmonth, self.startday,
                                self.starthour, self.startmin, self.startsec)
        dt2 = datetime.datetime(other.startyear, other.startmonth, other.startday,
                                other.starthour, other.startmin, other.startsec)
        return (dt1 &gt;= dt2)</code></pre>
</details>
</dd>
<dt id="madrigalWeb.madrigalWeb.MadrigalExperimentFile"><code class="flex name class">
<span>class <span class="ident">MadrigalExperimentFile</span></span>
<span>(</span><span>name, kindat, kindatdesc, category, status, permission, expId=None, doi=None)</span>
</code></dt>
<dd>
<div class="desc"><p>MadrigalExperimentFile is a class that encapsulates information about a Madrigal ExperimentFile.</p>
<p>Attributes::</p>
<pre><code>name (string) Example '/opt/mdarigal/blah/mlh980120g.001'

kindat (int) Kindat code.  Example: 3001

kindatdesc (string) Kindat description: Example 'Basic Derived Parameters'

category (int) (1=default, 2=variant, 3=history, 4=real-time)

status (string)('preliminary', 'final', or any other description)

permission (int)  0 for public, 1 for private

expId - experiment id of the experiment this MadrigalExperimentFile belongs in

doi - digital object identifier - citable url to file - or None if not found
</code></pre>
<p>Non-standard Python modules used: None</p>
<p>Change history:</p>
<p>Written by "Bill Rideout":mailto:wrideout@haystack.mit.edu
Feb. 10, 2004</p>
<p><strong>init</strong> initializes a MadrigalExperimentFile.</p>
<p>Inputs::</p>
<pre><code>name - (string) Example '/opt/mdarigal/blah/mlh980120g.001'

kindat - (int, or string that can be converted) Kindat code.  Example: 3001

kindatdesc - (string) Kindat description: Example 'Basic Derived Parameters'

category - (int, or string that can be converted) (1=default, 2=variant, 3=history, 4=real-time)

status - (string)('preliminary', 'final', or any other description)

permission - (int, or string that can be converted)  0 for public, 1 for private

expId - experiment id of the experiment this MadrigalExperimentFile belongs in

doi - digital object identifier - citable url to file. Default is None
</code></pre>
<p>Returns: void</p>
<p>Affects: Initializes all the class member variables.</p>
<p>Exceptions: If illegal argument passed in.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MadrigalExperimentFile:
    &#34;&#34;&#34;MadrigalExperimentFile is a class that encapsulates information about a Madrigal ExperimentFile.


    Attributes::

        name (string) Example &#39;/opt/mdarigal/blah/mlh980120g.001&#39;
        
        kindat (int) Kindat code.  Example: 3001
        
        kindatdesc (string) Kindat description: Example &#39;Basic Derived Parameters&#39;
        
        category (int) (1=default, 2=variant, 3=history, 4=real-time)
        
        status (string)(&#39;preliminary&#39;, &#39;final&#39;, or any other description)
        
        permission (int)  0 for public, 1 for private

        expId - experiment id of the experiment this MadrigalExperimentFile belongs in
        
        doi - digital object identifier - citable url to file - or None if not found
            

    Non-standard Python modules used: None


    Change history:

    Written by &#34;Bill Rideout&#34;:mailto:wrideout@haystack.mit.edu  Feb. 10, 2004

    &#34;&#34;&#34;
    def __init__(self, name, kindat, kindatdesc, category, status, permission, expId = None, doi=None):
        &#34;&#34;&#34;__init__ initializes a MadrigalExperimentFile.

        Inputs::

            name - (string) Example &#39;/opt/mdarigal/blah/mlh980120g.001&#39;
        
            kindat - (int, or string that can be converted) Kindat code.  Example: 3001
        
            kindatdesc - (string) Kindat description: Example &#39;Basic Derived Parameters&#39;
        
            category - (int, or string that can be converted) (1=default, 2=variant, 3=history, 4=real-time)
        
            status - (string)(&#39;preliminary&#39;, &#39;final&#39;, or any other description)
        
            permission - (int, or string that can be converted)  0 for public, 1 for private

            expId - experiment id of the experiment this MadrigalExperimentFile belongs in
            
            doi - digital object identifier - citable url to file. Default is None

        
        Returns: void

        Affects: Initializes all the class member variables.

        Exceptions: If illegal argument passed in.
        &#34;&#34;&#34;

        if not isStringType(name):
            raise ValueError(&#39;In MadrigalExperimentFile, name not string type: %s&#39; % (str(name)))

        self.name = name

        self.kindat = int(kindat)

        if not isStringType(kindatdesc):
            raise ValueError(&#39;In MadrigalExperimentFile, kindatdesc not string type: %s&#39; % (str(kindatdesc)))

        self.kindatdesc = kindatdesc

        self.category = int(category)

        if not isStringType(status):
            raise ValueError(&#39;In MadrigalExperimentFile, status not string type: %s&#39; % (str(status)))

        self.status = status

        self.permission = int(permission)

        if expId == None:
            self.expId = None
        else:
            self.expId = int(expId)
            
        if not isStringType(doi) and not doi is None:
            raise ValueError(&#39;In MadrigalExperimentFile, doi not string type or None: %s&#39; % (str(doi)))
        self.doi = doi
            
        

    def __str__(self):
        &#34;&#34;&#34;return a readable form of this object&#34;&#34;&#34;
        retStr = &#39;&#39;
        retStr += &#39;name: %s\n&#39; % (self.name)
        retStr += &#39;kindat: %s\n&#39; % (str(self.kindat))
        retStr += &#39;kindatdesc: %s\n&#39; % (self.kindatdesc)
        retStr += &#39;category: %s\n&#39; % (str(self.category))
        retStr += &#39;status: %s\n&#39; % (self.status)
        retStr += &#39;permission: %s\n&#39;%  (str(self.permission))
        retStr += &#39;expId: %s\n&#39;%  (str(self.expId))
        retStr += &#39;doi: %s\n&#39;%  (self.doi)
        return retStr</code></pre>
</details>
</dd>
<dt id="madrigalWeb.madrigalWeb.MadrigalInstrument"><code class="flex name class">
<span>class <span class="ident">MadrigalInstrument</span></span>
<span>(</span><span>name, code, mnemonic, latitude, longitude, altitude, category='unknown')</span>
</code></dt>
<dd>
<div class="desc"><p>MadrigalInstrument is a class that encapsulates information about a Madrigal Instrument.</p>
<p>Attributes::</p>
<p>name (string) Example: 'Millstone Hill Incoherent Scatter Radar'</p>
<p>code (int) Example: 30</p>
<p>mnemonic (3 char string) Example: 'mlh'</p>
<p>latitude (double) Example: 45.0</p>
<p>longitude (double) Example: 110.0</p>
<p>altitude (double)
Example: 0.015 (km)</p>
<p>category (string) Example 'Incoherent Scatter Radars'</p>
<p>Non-standard Python modules used: None</p>
<p>Change history:</p>
<p>Written by "Bill Rideout":mailto:wrideout@haystack.mit.edu
Feb. 10, 2004</p>
<p><strong>init</strong> initializes a MadrigalInstrument.</p>
<p>Inputs::</p>
<pre><code>name - (string) Example: 'Millstone Hill Incoherent Scatter Radar'

code - (int, or string that can be converted) Example: 30

mnemonic - (3 char string) Example: 'mlh'

latitude - (double, or string that can be converted) Example: 45.0

longitude (double, or string that can be converted) Example: 110.0

altitude (double, or string that can be converted)  Example: 0.015 (km)

category  (string) Example: 'Incoherent Scatter Radars'
</code></pre>
<p>Returns: void</p>
<p>Affects: Initializes all the class member variables.</p>
<p>Exceptions: If illegal argument passed in.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MadrigalInstrument:
    &#34;&#34;&#34;MadrigalInstrument is a class that encapsulates information about a Madrigal Instrument.


    Attributes::

      name (string) Example: &#39;Millstone Hill Incoherent Scatter Radar&#39;
      
      code (int) Example: 30
      
      mnemonic (3 char string) Example: &#39;mlh&#39;
      
      latitude (double) Example: 45.0
      
      longitude (double) Example: 110.0
      
      altitude (double)  Example: 0.015 (km)
      
      category (string) Example &#39;Incoherent Scatter Radars&#39;
            


    Non-standard Python modules used: None


    Change history:

    Written by &#34;Bill Rideout&#34;:mailto:wrideout@haystack.mit.edu  Feb. 10, 2004

    &#34;&#34;&#34;
    def __init__(self, name, code, mnemonic, latitude, longitude, altitude, category=&#39;unknown&#39;):
        &#34;&#34;&#34;__init__ initializes a MadrigalInstrument.

        Inputs::

            name - (string) Example: &#39;Millstone Hill Incoherent Scatter Radar&#39;
          
            code - (int, or string that can be converted) Example: 30
          
            mnemonic - (3 char string) Example: &#39;mlh&#39;
          
            latitude - (double, or string that can be converted) Example: 45.0
          
            longitude (double, or string that can be converted) Example: 110.0
          
            altitude (double, or string that can be converted)  Example: 0.015 (km)
            
            category  (string) Example: &#39;Incoherent Scatter Radars&#39;
        
        Returns: void

        Affects: Initializes all the class member variables.

        Exceptions: If illegal argument passed in.
        &#34;&#34;&#34;

        if not isStringType(name):
            raise ValueError(&#39;In MadrigalInstrument, name not string type: %s&#39; % (str(name)))

        self.name = name

        self.code = int(code)

        if not isStringType(mnemonic):
            raise ValueError(&#39;In MadrigalInstrument, mnemonic not string type: %s&#39; % (str(mnemonic)))

        if len(mnemonic) != 3:
            raise ValueError(&#39;In MadrigalInstrument, mnemonic not three characters: %s&#39; % (str(mnemonic)))

        self.mnemonic = mnemonic.lower()

        self.latitude = float(latitude)

        self.longitude = float(longitude)

        self.altitude = float(altitude)
        
        if not isStringType(category):
            raise ValueError(&#39;In MadrigalInstrument, category not string type: %s&#39; % (str(category)))
        
        self.category = category
        

    def __str__(self):
        &#34;&#34;&#34;return a readible form of this object&#34;&#34;&#34;
        retStr = &#39;&#39;
        retStr += &#39;name: %s\n&#39; % (self.name)
        retStr += &#39;code: %s\n&#39; % (str(self.code))
        retStr += &#39;mnemonic: %s\n&#39; % (self.mnemonic)
        retStr += &#39;latitude: %s\n&#39; % (str(self.latitude))
        retStr += &#39;longitude: %s\n&#39; % (str(self.longitude))
        retStr += &#39;altitude: %s\n&#39;%  (str(self.altitude))
        retStr += &#39;category: %s\n&#39;%  (self.category)
        return retStr</code></pre>
</details>
</dd>
<dt id="madrigalWeb.madrigalWeb.MadrigalParameter"><code class="flex name class">
<span>class <span class="ident">MadrigalParameter</span></span>
<span>(</span><span>mnemonic, description, isError, units, isMeasured, category, isSure, isAddIncrement)</span>
</code></dt>
<dd>
<div class="desc"><p>MadrigalParameter is a class that encapsulates information about a Madrigal Parameter.</p>
<p>Attributes::</p>
<pre><code>mnemonic (string) Example 'dti'

description (string) Example: "F10.7 Multiday average observed (Ott)"

isError (int) 1 if error parameter, 0 if not

units (string) Example "W/m2/Hz"

isMeasured (int) 1 if measured, 0 if derivable

category (string) Example: "Time Related Parameter"

isSure (int) - 1 if parameter can be found for every record, 0 if can only be found for some

isAddIncrement - 1 if additional increment, 0 if normal, -1 if unknown (this capability
                 only added with Madrigal 2.5)
</code></pre>
<p>Non-standard Python modules used: None</p>
<p>Change history:</p>
<p>Written by "Bill Rideout":mailto:wrideout@haystack.mit.edu
Aug. 8, 2005</p>
<p><strong>init</strong> initializes a MadrigalParameter.</p>
<p>Inputs::</p>
<pre><code>mnemonic (string) Example 'dti'

description (string) Example: "F10.7 Multiday average observed (Ott)"

isError (int) 1 if error parameter, 0 if not

units (string) Example "W/m2/Hz"

isMeasured (int) 1 if measured, 0 if derivable

category (string) Example: "Time Related Parameter"

isSure (int) - 1 if parameter can be found for every record, 0 if can only be found for some

isAddIncrement - 1 if additional increment, 0 if normal, -1 if unknown (this capability
                 only added with Madrigal 2.5)
</code></pre>
<p>Returns: void</p>
<p>Affects: Initializes all the class member variables.</p>
<p>Exceptions: If illegal argument passed in.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MadrigalParameter:
    &#34;&#34;&#34;MadrigalParameter is a class that encapsulates information about a Madrigal Parameter.


    Attributes::

        mnemonic (string) Example &#39;dti&#39;

        description (string) Example: &#34;F10.7 Multiday average observed (Ott)&#34;

        isError (int) 1 if error parameter, 0 if not

        units (string) Example &#34;W/m2/Hz&#34;

        isMeasured (int) 1 if measured, 0 if derivable

        category (string) Example: &#34;Time Related Parameter&#34;

        isSure (int) - 1 if parameter can be found for every record, 0 if can only be found for some

        isAddIncrement - 1 if additional increment, 0 if normal, -1 if unknown (this capability
                         only added with Madrigal 2.5)


    Non-standard Python modules used: None


    Change history:

    Written by &#34;Bill Rideout&#34;:mailto:wrideout@haystack.mit.edu  Aug. 8, 2005

    &#34;&#34;&#34;
    def __init__(self, mnemonic, description, isError, units, isMeasured, category, isSure, isAddIncrement):
        &#34;&#34;&#34;__init__ initializes a MadrigalParameter.

        Inputs::

            mnemonic (string) Example &#39;dti&#39;

            description (string) Example: &#34;F10.7 Multiday average observed (Ott)&#34;

            isError (int) 1 if error parameter, 0 if not

            units (string) Example &#34;W/m2/Hz&#34;

            isMeasured (int) 1 if measured, 0 if derivable

            category (string) Example: &#34;Time Related Parameter&#34;

            isSure (int) - 1 if parameter can be found for every record, 0 if can only be found for some

            isAddIncrement - 1 if additional increment, 0 if normal, -1 if unknown (this capability
                             only added with Madrigal 2.5)
 

        Returns: void

        Affects: Initializes all the class member variables.

        Exceptions: If illegal argument passed in.
        &#34;&#34;&#34;

        if not isStringType(mnemonic):
            raise ValueError(&#39;In MadrigalParameter, mnemonic not string type: %s&#39; % (str(mnemonic)))

        self.mnemonic = mnemonic

        if not isStringType(description):
            raise ValueError(&#39;In MadrigalParameter, description not string type: %s&#39; % (str(description)))

        self.description = description

        self.isError = int(isError)

        if not isStringType(units):
            raise ValueError(&#39;In MadrigalParameter, units not string type: %s&#39; % (str(units)))

        self.units = units

        self.isMeasured = int(isMeasured)

        if not isStringType(category):
            raise ValueError(&#39;In MadrigalParameter, category not string type: %s&#39; % (str(category)))

        self.category = category
            
        self.isSure = int(isSure)

        self.isAddIncrement = int(isAddIncrement)
        

    def __str__(self):
        &#34;&#34;&#34;return a readible form of this object&#34;&#34;&#34;
        retStr = &#39;&#39;
        retStr += &#39;mnemonic: %s\n&#39; % (self.mnemonic)
        retStr += &#39;description: %s\n&#39; % (self.description)
        retStr += &#39;isError: %s\n&#39; % (str(self.isError))
        retStr += &#39;units: %s\n&#39; % (self.units)
        retStr += &#39;isMeasured: %s\n&#39; % (str(self.isMeasured))
        retStr += &#39;category: %s\n&#39;%  (self.category)
        retStr += &#39;isSure: %s\n&#39;%  (str(self.isSure))
        retStr += &#39;isAddIncrement: %s\n&#39;%  (str(self.isAddIncrement))
        return retStr     </code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="madrigalWeb.madrigalWeb.isStringType" href="#madrigalWeb.madrigalWeb.isStringType">isStringType</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="madrigalWeb.madrigalWeb.MadrigalData" href="#madrigalWeb.madrigalWeb.MadrigalData">MadrigalData</a></code></h4>
<ul class="">
<li><code><a title="madrigalWeb.madrigalWeb.MadrigalData.compareVersions" href="#madrigalWeb.madrigalWeb.MadrigalData.compareVersions">compareVersions</a></code></li>
<li><code><a title="madrigalWeb.madrigalWeb.MadrigalData.createCitationGroupFromList" href="#madrigalWeb.madrigalWeb.MadrigalData.createCitationGroupFromList">createCitationGroupFromList</a></code></li>
<li><code><a title="madrigalWeb.madrigalWeb.MadrigalData.downloadFile" href="#madrigalWeb.madrigalWeb.MadrigalData.downloadFile">downloadFile</a></code></li>
<li><code><a title="madrigalWeb.madrigalWeb.MadrigalData.downloadWebFile" href="#madrigalWeb.madrigalWeb.MadrigalData.downloadWebFile">downloadWebFile</a></code></li>
<li><code><a title="madrigalWeb.madrigalWeb.MadrigalData.geodeticToRadar" href="#madrigalWeb.madrigalWeb.MadrigalData.geodeticToRadar">geodeticToRadar</a></code></li>
<li><code><a title="madrigalWeb.madrigalWeb.MadrigalData.getAllInstruments" href="#madrigalWeb.madrigalWeb.MadrigalData.getAllInstruments">getAllInstruments</a></code></li>
<li><code><a title="madrigalWeb.madrigalWeb.MadrigalData.getCitationListFromFilters" href="#madrigalWeb.madrigalWeb.MadrigalData.getCitationListFromFilters">getCitationListFromFilters</a></code></li>
<li><code><a title="madrigalWeb.madrigalWeb.MadrigalData.getCitedFilesFromUrl" href="#madrigalWeb.madrigalWeb.MadrigalData.getCitedFilesFromUrl">getCitedFilesFromUrl</a></code></li>
<li><code><a title="madrigalWeb.madrigalWeb.MadrigalData.getExperimentFileParameters" href="#madrigalWeb.madrigalWeb.MadrigalData.getExperimentFileParameters">getExperimentFileParameters</a></code></li>
<li><code><a title="madrigalWeb.madrigalWeb.MadrigalData.getExperimentFiles" href="#madrigalWeb.madrigalWeb.MadrigalData.getExperimentFiles">getExperimentFiles</a></code></li>
<li><code><a title="madrigalWeb.madrigalWeb.MadrigalData.getExperiments" href="#madrigalWeb.madrigalWeb.MadrigalData.getExperiments">getExperiments</a></code></li>
<li><code><a title="madrigalWeb.madrigalWeb.MadrigalData.getVersion" href="#madrigalWeb.madrigalWeb.MadrigalData.getVersion">getVersion</a></code></li>
<li><code><a title="madrigalWeb.madrigalWeb.MadrigalData.isprint" href="#madrigalWeb.madrigalWeb.MadrigalData.isprint">isprint</a></code></li>
<li><code><a title="madrigalWeb.madrigalWeb.MadrigalData.listFileTimes" href="#madrigalWeb.madrigalWeb.MadrigalData.listFileTimes">listFileTimes</a></code></li>
<li><code><a title="madrigalWeb.madrigalWeb.MadrigalData.madCalculator" href="#madrigalWeb.madrigalWeb.MadrigalData.madCalculator">madCalculator</a></code></li>
<li><code><a title="madrigalWeb.madrigalWeb.MadrigalData.madCalculator2" href="#madrigalWeb.madrigalWeb.MadrigalData.madCalculator2">madCalculator2</a></code></li>
<li><code><a title="madrigalWeb.madrigalWeb.MadrigalData.madCalculator3" href="#madrigalWeb.madrigalWeb.MadrigalData.madCalculator3">madCalculator3</a></code></li>
<li><code><a title="madrigalWeb.madrigalWeb.MadrigalData.madTimeCalculator" href="#madrigalWeb.madrigalWeb.MadrigalData.madTimeCalculator">madTimeCalculator</a></code></li>
<li><code><a title="madrigalWeb.madrigalWeb.MadrigalData.radarToGeodetic" href="#madrigalWeb.madrigalWeb.MadrigalData.radarToGeodetic">radarToGeodetic</a></code></li>
<li><code><a title="madrigalWeb.madrigalWeb.MadrigalData.simplePrint" href="#madrigalWeb.madrigalWeb.MadrigalData.simplePrint">simplePrint</a></code></li>
<li><code><a title="madrigalWeb.madrigalWeb.MadrigalData.traceMagneticField" href="#madrigalWeb.madrigalWeb.MadrigalData.traceMagneticField">traceMagneticField</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="madrigalWeb.madrigalWeb.MadrigalExperiment" href="#madrigalWeb.madrigalWeb.MadrigalExperiment">MadrigalExperiment</a></code></h4>
</li>
<li>
<h4><code><a title="madrigalWeb.madrigalWeb.MadrigalExperimentFile" href="#madrigalWeb.madrigalWeb.MadrigalExperimentFile">MadrigalExperimentFile</a></code></h4>
</li>
<li>
<h4><code><a title="madrigalWeb.madrigalWeb.MadrigalInstrument" href="#madrigalWeb.madrigalWeb.MadrigalInstrument">MadrigalInstrument</a></code></h4>
</li>
<li>
<h4><code><a title="madrigalWeb.madrigalWeb.MadrigalParameter" href="#madrigalWeb.madrigalWeb.MadrigalParameter">MadrigalParameter</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>